{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../lib/index.js",
    "../lib/node/path.js",
    "../lib/node/url.js",
    "../lib/omni-path.js",
    "../lib/omni-posix.js",
    "../lib/omni-url.js",
    "../lib/omni-windows.js",
    "../lib/util.js",
    "../node_modules/process/browser.js",
    "../node_modules/punycode/punycode.js",
    "../node_modules/querystring-es3/decode.js",
    "../node_modules/querystring-es3/encode.js",
    "../node_modules/querystring-es3/index.js"
  ],
  "names": [
    "f",
    "exports",
    "module",
    "define",
    "amd",
    "g",
    "window",
    "global",
    "self",
    "this",
    "OmniPath",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "require",
    "i",
    "Error",
    "code",
    "l",
    "call",
    "length",
    "1",
    "Posix",
    "posix",
    "Windows",
    "windows",
    "win32",
    "Url",
    "url",
    "pop",
    "push",
    "slice",
    "exec",
    "device",
    "isUnc",
    "isAbsolute",
    "tail",
    "replace",
    "p",
    "process",
    "platform",
    "c",
    "resolve",
    "arguments",
    "env",
    "substr",
    "toLowerCase",
    "cwd",
    "isString",
    "TypeError",
    "h",
    "split",
    "join",
    "normalize",
    "test",
    "relative",
    "Math",
    "min",
    "concat",
    "_makeLong",
    "substring",
    "dirname",
    "basename",
    "extname",
    "format",
    "isObject",
    "root",
    "dir",
    "base",
    "sep",
    "parse",
    "ext",
    "name",
    "delimiter",
    "charAt",
    "protocol",
    "slashes",
    "auth",
    "host",
    "port",
    "hostname",
    "hash",
    "search",
    "query",
    "pathname",
    "path",
    "href",
    "prototype",
    "resolveObject",
    "m",
    "v",
    "y",
    "b",
    "javascript",
    "javascript:",
    "q",
    "d",
    "http",
    "https",
    "ftp",
    "gopher",
    "file",
    "http:",
    "https:",
    "ftp:",
    "gopher:",
    "file:",
    "x",
    "indexOf",
    "trim",
    "O",
    "j",
    "match",
    "A",
    "w",
    "C",
    "I",
    "U",
    "k",
    "lastIndexOf",
    "decodeURIComponent",
    "parseHost",
    "N",
    "R",
    "S",
    "$",
    "z",
    "H",
    "L",
    "charCodeAt",
    "Z",
    "_",
    "E",
    "unshift",
    "toASCII",
    "P",
    "T",
    "B",
    "D",
    "encodeURIComponent",
    "escape",
    "F",
    "G",
    "J",
    "Object",
    "keys",
    "stringify",
    "shift",
    "isNullOrUndefined",
    "isNull",
    "splice",
    "clone",
    "util",
    "toString",
    "getType",
    "isUrl",
    "isWindows",
    "callSubclassMethod",
    "apply",
    "querystring",
    "parts",
    "forEach",
    "props",
    "_path",
    "Array",
    "fastParse",
    "pathnames",
    "searches",
    "last",
    "hashes",
    "hasUrls",
    "hrefs",
    "browser",
    "_getFormattedSearchAndHash",
    "formatPart",
    "valueOf",
    "toUrl",
    "toUrlString",
    "backslashPattern",
    "location",
    "constructor",
    "copy",
    "_options",
    "isFS",
    "isPosix",
    "toJSON",
    "OmniPosix",
    "inherits",
    "parsePath",
    "OmniUrl",
    "slashesPattern",
    "looseProtocolPattern",
    "_getFormattedPathname",
    "endsWithAnySeparator",
    "startsWithAnySeparator",
    "getArgs",
    "paths",
    "OmniWindows",
    "uncPattern",
    "splitUncPattern",
    "create",
    "protocolPattern",
    "allowFileHash",
    "allowFileQuery",
    "parseQueryString",
    "options",
    "defaultSetTimout",
    "defaultClearTimeout",
    "runTimeout",
    "cachedSetTimeout",
    "setTimeout",
    "runClearTimeout",
    "cachedClearTimeout",
    "clearTimeout",
    "cleanUpNextTick",
    "draining",
    "currentQueue",
    "queue",
    "queueIndex",
    "drainQueue",
    "run",
    "Item",
    "fun",
    "array",
    "noop",
    "nextTick",
    "title",
    "argv",
    "version",
    "versions",
    "on",
    "addListener",
    "once",
    "off",
    "removeListener",
    "removeAllListeners",
    "emit",
    "prependListener",
    "prependOnceListener",
    "listeners",
    "binding",
    "chdir",
    "umask",
    "RangeError",
    "M",
    "nodeType",
    "overflow",
    "not-basic",
    "invalid-input",
    "floor",
    "String",
    "fromCharCode",
    "ucs2",
    "decode",
    "encode",
    "toUnicode",
    "hasOwnProperty",
    "punycode",
    "maxKeys",
    "isArray",
    "map",
    "stringifyPrimitive",
    "isFinite",
    "objectKeys"
  ],
  "mappings": ";;;;;;;;CAAA,SAAAA,GAAA,SAAAC,WAAA,gBAAAC,UAAA,YAAA,CAAAA,OAAAD,QAAAD,QAAA,UAAAG,UAAA,YAAAA,OAAAC,IAAA,CAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAA,UAAAC,UAAA,YAAA,CAAAD,EAAAC,WAAA,UAAAC,UAAA,YAAA,CAAAF,EAAAE,WAAA,UAAAC,QAAA,YAAA,CAAAH,EAAAG,SAAA,CAAAH,EAAAI,KAAAJ,EAAAK,SAAAV,OAAA,WAAA,GAAAG,QAAAD,OAAAD,OAAA,OAAA,SAAAU,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,SAAAC,UAAA,YAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAhB,GAAA,GAAAqB,OAAA,uBAAAL,EAAA,IAAA,MAAAhB,GAAAsB,KAAA,mBAAAtB,EAAA,GAAAuB,GAAAV,EAAAG,IAAAf,WAAAW,GAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAf,QAAA,GAAAmB,SAAAD,UAAA,YAAAA,OAAA,KAAA,GAAAH,GAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,QAAAjB,OAAAD,SCAA,YAEAC,QAAOD,QAAUkB,QAAQ,eACzBjB,OAAOD,QAAQ0B,MAAQzB,OAAOD,QAAQ2B,MAAQT,QAAQ,gBACtDjB,OAAOD,QAAQ4B,QAAU3B,OAAOD,QAAQ6B,QAAU5B,OAAOD,QAAQ8B,MAAQZ,QAAQ,kBACjFjB,OAAOD,QAAQ+B,IAAM9B,OAAOD,QAAQgC,IAAMd,QAAQ,6ICJjD,WACC,YA4CA,SAASL,GAAgBA,EAAOH,GAE9B,IAAK,GADDC,MACKC,EAAI,EAAGA,EAAIC,EAAMW,OAAQZ,IAAK,CACrC,GAAIG,GAAIF,EAAMD,EAGTG,IAAW,MAANA,IAEA,OAANA,EACEJ,EAAIa,QAAkC,OAAxBb,EAAIA,EAAIa,OAAS,GACjCb,EAAIsB,MAEGvB,GACPC,EAAIuB,KAAK,MAIXvB,EAAIuB,KAAKnB,IAIb,MAAOJ,GAKT,QAASD,GAAWG,GAGlB,IAFA,GAAIH,GAAYG,EAAIW,OAAS,EACzBb,EAAQ,EACLA,GAASD,IACVG,EAAIF,GADiBA,KAK3B,IADA,GAAIC,GAAMF,EACHE,GAAO,IACRC,EAAID,GADOA,KAIjB,MAAc,KAAVD,GAAeC,IAAQF,EAAoBG,EAC3CF,EAAQC,KACLC,EAAIsB,MAAMxB,EAAOC,EAAM,GAehC,QAASD,GAAgBE,GAEvB,GAAIH,GAASY,EAAcc,KAAKvB,GAC5BF,GAAUD,EAAO,IAAM,KAAOA,EAAO,IAAM,IAC3CE,EAAOF,EAAO,IAAM,GAEpBK,EAAUhB,EAAYqC,KAAKxB,EAI/B,QAAQD,EAHEI,EAAQ,GACHA,EAAQ,GACbA,EAAQ,IAIpB,QAASH,GAAeC,GACtB,GAAIH,GAASY,EAAcc,KAAKvB,GAC5BF,EAASD,EAAO,IAAM,GACtBE,IAAUD,GAAwB,MAAdA,EAAO,EAC/B,QACE0B,OAAQ1B,EACR2B,MAAO1B,EACP2B,WAAY3B,KAAWF,EAAO,GAC9B8B,KAAM9B,EAAO,IAIjB,QAASK,GAAkBF,GACzB,MAAO,OAASA,EAAO4B,QAAQ,WAAY,IAAIA,QAAQ,WAAY,MAuTrE,QAAStB,GAAgBN,GACvB,MAAO6B,GAAYN,KAAKvB,GAAUsB,MAAM,GAnb1C,GAAIrB,GAAOI,QAAQ,OAEnB,IAAIJ,EAAKa,OAASb,EAAKe,QAGrB,YADA5B,OAAOD,QAAUc,EA8BnB,IAAIG,GAAiC,UAArB0B,QAAQC,SACpB5B,EAAOE,QAAQ,WAoDfI,EACA,qEAGAvB,EACA,gEAEA8C,IAiCJA,GAAMC,QAAU,WAKd,IAAK,GAJDpC,GAAiB,GACjBC,EAAe,GACfQ,GAAmB,EAEdL,EAAIiC,UAAUvB,OAAS,EAAGV,IAAM,EAAGA,IAAK,CAC/C,GAAIG,EAsBJ,IArBIH,GAAK,EACPG,EAAO8B,UAAUjC,GAETJ,GAQRO,EAAO0B,QAAQK,IAAI,IAAMtC,KAGZO,EAAKgC,OAAO,EAAG,GAAGC,gBAC3BxC,EAAewC,cAAgB,OACjCjC,EAAOP,EAAiB,MAZ1BO,EAAO0B,QAAQQ,OAiBZnC,EAAKoC,SAASnC,GACjB,KAAM,IAAIoC,WAAU,4CAEjB,IAAKpC,EAAL,CAIL,GAAIK,GAASV,EAAcK,GACvBlB,EAASuB,EAAOe,OAChBQ,EAAQvB,EAAOgB,MACfI,EAAapB,EAAOiB,WACpBe,EAAOhC,EAAOkB,IAElB,MAAIzC,IACAW,GACAX,EAAOmD,gBAAkBxC,EAAewC,iBAKvCxC,IACHA,EAAiBX,GAEdoB,IACHR,EAAe2C,EAAO,KAAO3C,EAC7BQ,EAAmBuB,GAGjBhC,GAAkBS,GACpB,OAkBJ,MAZI0B,KACFnC,EAAiBK,EAAiBL,IAQpCC,EAAeE,EAAeF,EAAa4C,MAAM,YAC9CpC,GAAkBqC,KAAK,MAElB9C,GAAkBS,EAAmB,KAAO,IAAMR,GACnD,KAITkC,EAAMY,UAAY,SAAU/C,GAC1B,GAAIC,GAASC,EAAcF,GACvBS,EAASR,EAAO0B,OAChBvB,EAAQH,EAAO2B,MACfrB,EAAaN,EAAO4B,WACpBvB,EAAOL,EAAO6B,KACdlB,EAAgB,UAAUoC,KAAK1C,EAkBnC,OAfAA,GAAOH,EAAeG,EAAKuC,MAAM,YAAatC,GAAYuC,KAAK,MAE1DxC,GAASC,IACZD,EAAO,KAELA,GAAQM,IACVN,GAAQ,MAKNF,IACFK,EAASJ,EAAiBI,IAGrBA,GAAUF,EAAa,KAAO,IAAMD,GAI7C6B,EAAMN,WAAa,SAAU1B,GAC3B,MAAOD,GAAcC,GAAM0B,YAG7BM,EAAMW,KAAO,WAEX,IAAK,GADD3C,MACKH,EAAI,EAAGA,EAAIqC,UAAUvB,OAAQd,IAAK,CACzC,GAAIC,GAAMoC,UAAUrC,EACpB,KAAKM,EAAKoC,SAASzC,GACjB,KAAM,IAAI0C,WAAU,yCAElB1C,IACFE,EAAMqB,KAAKvB,GAIf,GAAIC,GAASC,EAAM2C,KAAK,KAmBxB,OAJK,oBAAoBE,KAAK7C,EAAM,MAClCD,EAASA,EAAO6B,QAAQ,cAAe,OAGlCI,EAAMY,UAAU7C,IASzBiC,EAAMc,SAAW,SAAU9C,EAAMF,GAC/BE,EAAOgC,EAAMC,QAAQjC,GACrBF,EAAKkC,EAAMC,QAAQnC,EAanB,KAAK,GAVDC,GAAYC,EAAKqC,cACjBnC,EAAUJ,EAAGuC,cAEb/B,EAAUT,EAAUC,EAAG4C,MAAM,OAE7BzC,EAAiBJ,EAAUE,EAAU2C,MAAM,OAC3CtC,EAAeP,EAAUK,EAAQwC,MAAM,OAEvCvC,EAAS4C,KAAKC,IAAI/C,EAAeU,OAAQP,EAAaO,QACtDF,EAAkBN,EACbjB,EAAI,EAAGA,EAAIiB,EAAQjB,IAC1B,GAAIe,EAAef,KAAOkB,EAAalB,GAAI,CACzCuB,EAAkBvB,CAClB,OAIJ,GAAuB,GAAnBuB,EACF,MAAOX,EAIT,KAAK,GADD+B,MACK3C,EAAIuB,EAAiBvB,EAAIe,EAAeU,OAAQzB,IACvD2C,EAAYR,KAAK,KAKnB,OAFAQ,GAAcA,EAAYoB,OAAO3C,EAAQgB,MAAMb,IAExCoB,EAAYc,KAAK,OAI1BX,EAAMkB,UAAY,SAAUlD,GAE1B,IAAKG,EAAKoC,SAASvC,GAAS,MAAOA,EAEnC,KAAKA,EACH,MAAO,EAGT,IAAIH,GAAemC,EAAMC,QAAQjC,EAEjC,OAAI,gBAAgB6C,KAAKhD,GAGhB,UAAYA,EAEZ,aAAagD,KAAKhD,GAGlB,eAAiBA,EAAasD,UAAU,GAG1CnD,GAITgC,EAAMoB,QAAU,SAAUpD,GACxB,GAAIH,GAASC,EAAeE,GACxBD,EAAOF,EAAO,GACdK,EAAML,EAAO,EAEjB,OAAKE,IAASG,GAKVA,IAEFA,EAAMA,EAAIkC,OAAO,EAAGlC,EAAIS,OAAS,IAG5BZ,EAAOG,GARL,KAYX8B,EAAMqB,SAAW,SAAUrD,EAAMH,GAC/B,GAAIE,GAAID,EAAeE,GAAM,EAK7B,OAHIH,IAAOE,EAAEqC,QAAQ,EAAIvC,EAAIc,UAAYd,IACvCE,EAAIA,EAAEqC,OAAO,EAAGrC,EAAEY,OAASd,EAAIc,SAE1BZ,GAITiC,EAAMsB,QAAU,SAAUtD,GACxB,MAAOF,GAAeE,GAAM,IAI9BgC,EAAMuB,OAAS,SAAUvD,GACvB,IAAKG,EAAKqD,SAASxD,GACjB,KAAM,IAAIwC,WACR,uDAA0DxC,GAI9D,IAAIH,GAAOG,EAAWyD,MAAQ,EAE9B,KAAKtD,EAAKoC,SAAS1C,GACjB,KAAM,IAAI2C,WACR,8DACSxC,GAAWyD,KAIxB,IAAI3D,GAAME,EAAW0D,IACjB3D,EAAOC,EAAW2D,MAAQ,EAC9B,OAAK7D,GAGDA,EAAIA,EAAIa,OAAS,KAAOqB,EAAM4B,IACzB9D,EAAMC,EAERD,EAAMkC,EAAM4B,IAAM7D,EALhBA,GASXiC,EAAM6B,MAAQ,SAAU7D,GACtB,IAAKG,EAAKoC,SAASvC,GACjB,KAAM,IAAIwC,WACR,sDAAyDxC,GAG7D,IAAIH,GAAWC,EAAeE,EAC9B,KAAKH,GAAgC,IAApBA,EAASc,OACxB,KAAM,IAAI6B,WAAU,iBAAmBxC,EAAa,IAEtD,QACEyD,KAAM5D,EAAS,GACf6D,IAAK7D,EAAS,GAAKA,EAAS,GAAGyB,MAAM,GAAI,GACzCqC,KAAM9D,EAAS,GACfiE,IAAKjE,EAAS,GACdkE,KAAMlE,EAAS,GAAGyB,MAAM,EAAGzB,EAAS,GAAGc,OAASd,EAAS,GAAGc,UAKhEqB,EAAM4B,IAAM,KACZ5B,EAAMgC,UAAY,GAKlB,IAAInC,GACA,gEACAY,IAUJA,GAAMR,QAAU,WAId,IAAK,GAHDpC,GAAe,GACfC,GAAmB,EAEdC,EAAImC,UAAUvB,OAAS,EAAGZ,IAAM,IAAMD,EAAkBC,IAAK,CACpE,GAAIG,GAAQH,GAAK,EAAKmC,UAAUnC,GAAK+B,QAAQQ,KAG7C,KAAKnC,EAAKoC,SAASrC,GACjB,KAAM,IAAIsC,WAAU,4CAEZtC,KAIVL,EAAeK,EAAO,IAAML,EAC5BC,EAA+B,MAAZI,EAAK,IAU1B,MAHAL,GAAeG,EAAeH,EAAa6C,MAAM,MAC9C5C,GAAkB6C,KAAK,MAEjB7C,EAAmB,IAAM,IAAMD,GAAiB,KAK3D4C,EAAMG,UAAY,SAAU/C,GAC1B,GAAIC,GAAa2C,EAAMf,WAAW7B,GAC9BE,EAAgBF,GAAkC,MAA1BA,EAAKA,EAAKc,OAAS,EAY/C,OATAd,GAAOG,EAAeH,EAAK6C,MAAM,MAAO5C,GAAY6C,KAAK,KAEpD9C,GAASC,IACZD,EAAO,KAELA,GAAQE,IACVF,GAAQ,MAGFC,EAAa,IAAM,IAAMD,GAInC4C,EAAMf,WAAa,SAAU1B,GAC3B,MAA0B,MAAnBA,EAAKiE,OAAO,IAIrBxB,EAAME,KAAO,WAEX,IAAK,GADD3C,GAAO,GACFH,EAAI,EAAGA,EAAIqC,UAAUvB,OAAQd,IAAK,CACzC,GAAIC,GAAUoC,UAAUrC,EACxB,KAAKM,EAAKoC,SAASzC,GACjB,KAAM,IAAI0C,WAAU,yCAElB1C,KAKAE,GAJGA,EAIK,IAAMF,EAHNA,GAOd,MAAO2C,GAAMG,UAAU5C,IAMzByC,EAAMK,SAAW,SAAU9C,EAAMF,GAC/BE,EAAOyC,EAAMR,QAAQjC,GAAMoC,OAAO,GAClCtC,EAAK2C,EAAMR,QAAQnC,GAAIsC,OAAO,EAO9B,KAAK,GALDrC,GAAYF,EAAUG,EAAK0C,MAAM,MACjCxC,EAAUL,EAAUC,EAAG4C,MAAM,MAE7BpC,EAASyC,KAAKC,IAAIjD,EAAUY,OAAQT,EAAQS,QAC5CV,EAAkBK,EACbF,EAAI,EAAGA,EAAIE,EAAQF,IAC1B,GAAIL,EAAUK,KAAOF,EAAQE,GAAI,CAC/BH,EAAkBG,CAClB,OAKJ,IAAK,GADDD,MACKC,EAAIH,EAAiBG,EAAIL,EAAUY,OAAQP,IAClDD,EAAYkB,KAAK,KAKnB,OAFAlB,GAAcA,EAAY8C,OAAO/C,EAAQoB,MAAMrB,IAExCE,EAAYwC,KAAK,MAI1BF,EAAMS,UAAY,SAAUlD,GAC1B,MAAOA,IAITyC,EAAMW,QAAU,SAAUpD,GACxB,GAAIH,GAASS,EAAeN,GACxBF,EAAOD,EAAO,GACdE,EAAMF,EAAO,EAEjB,OAAKC,IAASC,GAKVA,IAEFA,EAAMA,EAAIqC,OAAO,EAAGrC,EAAIY,OAAS,IAG5Bb,EAAOC,GARL,KAYX0C,EAAMY,SAAW,SAAUrD,EAAMH,GAC/B,GAAIC,GAAIQ,EAAeN,GAAM,EAK7B,OAHIH,IAAOC,EAAEsC,QAAQ,EAAIvC,EAAIc,UAAYd,IACvCC,EAAIA,EAAEsC,OAAO,EAAGtC,EAAEa,OAASd,EAAIc,SAE1Bb,GAIT2C,EAAMa,QAAU,SAAUtD,GACxB,MAAOM,GAAeN,GAAM,IAI9ByC,EAAMc,OAAS,SAAUvD,GACvB,IAAKG,EAAKqD,SAASxD,GACjB,KAAM,IAAIwC,WACR,uDAA0DxC,GAI9D,IAAIH,GAAOG,EAAWyD,MAAQ,EAE9B,KAAKtD,EAAKoC,SAAS1C,GACjB,KAAM,IAAI2C,WACR,8DACSxC,GAAWyD,KAMxB,QAFUzD,EAAW0D,IAAM1D,EAAW0D,IAAMjB,EAAMmB,IAAM,KAC7C5D,EAAW2D,MAAQ,KAKhClB,EAAMoB,MAAQ,SAAU7D,GACtB,IAAKG,EAAKoC,SAASvC,GACjB,KAAM,IAAIwC,WACR,sDAAyDxC,GAG7D,IAAIH,GAAWS,EAAeN,EAC9B,KAAKH,GAAgC,IAApBA,EAASc,OACxB,KAAM,IAAI6B,WAAU,iBAAmBxC,EAAa,IAMtD,OAJAH,GAAS,GAAKA,EAAS,IAAM,GAC7BA,EAAS,GAAKA,EAAS,IAAM,GAC7BA,EAAS,GAAKA,EAAS,IAAM,IAG3B4D,KAAM5D,EAAS,GACf6D,IAAK7D,EAAS,GAAKA,EAAS,GAAGyB,MAAM,GAAI,GACzCqC,KAAM9D,EAAS,GACfiE,IAAKjE,EAAS,GACdkE,KAAMlE,EAAS,GAAGyB,MAAM,EAAGzB,EAAS,GAAGc,OAASd,EAAS,GAAGc,UAKhE8B,EAAMmB,IAAM,IACZnB,EAAMuB,UAAY,IAGD5E,OAAOD,QAApBiB,EAA8B4B,EAEfS,EAEnBrD,OAAOD,QAAQ2B,MAAQ2B,EACvBrD,OAAOD,QAAQ8B,MAAQe,6GCjoBxB,WACC,YA6CA,SAASlC,KACPH,KAAKuE,SAAW,KAChBvE,KAAKwE,QAAU,KACfxE,KAAKyE,KAAO,KACZzE,KAAK0E,KAAO,KACZ1E,KAAK2E,KAAO,KACZ3E,KAAK4E,SAAW,KAChB5E,KAAK6E,KAAO,KACZ7E,KAAK8E,OAAS,KACd9E,KAAK+E,MAAQ,KACb/E,KAAKgF,SAAW,KAChBhF,KAAKiF,KAAO,KACZjF,KAAKkF,KAAO,KAwDd,QAAS5E,GAAUA,EAAKwC,EAAkB5C,GACxC,GAAII,GAAOK,EAAKkD,SAASvD,IAAQA,YAAeH,GAAO,MAAOG,EAE9D,IAAIG,GAAI,GAAIN,EAEZ,OADAM,GAAEyD,MAAM5D,EAAKwC,EAAkB5C,GACxBO,EA2QT,QAASqC,GAAWA,GAMlB,MADInC,GAAKiC,SAASE,KAAQA,EAAMxC,EAASwC,IACnCA,YAAe3C,GACd2C,EAAIc,SADyBzD,EAAIgF,UAAUvB,OAAO7C,KAAK+B,GA8DhE,QAAS5C,GAAYC,EAAQ2C,GAC3B,MAAOxC,GAASH,GAAQ,GAAO,GAAMmC,QAAQQ,GAO/C,QAASrC,GAAkBN,EAAQ2C,GACjC,MAAK3C,GACEG,EAASH,GAAQ,GAAO,GAAMiF,cAActC,GAD7BA,EA5cxB,GAAIzC,GAAOK,QAAQ,OAEnB,IAAIL,EAAKc,OAASd,EAAKgB,QAGrB,YADA5B,OAAOD,QAAUkB,QAAQ,OA6B3B,IAAIH,GAAWG,QAAQ,YACnBC,EAAOD,QAAQ,UAEnBlB,SAAQ0E,MAAQ5D,EAChBd,QAAQ8C,QAAUpC,EAClBV,QAAQ4F,cAAgB3E,EACxBjB,QAAQoE,OAASd,EAEjBtD,QAAQ+B,IAAMpB,CAqBd,IAAIC,GAAkB,oBAClBU,EAAc,WAGdoB,EAAoB,qCAIpBG,GAAU,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,MAG/C7B,GAAU,IAAK,IAAK,IAAK,KAAM,IAAK,KAAK8C,OAAOjB,GAGhD9C,GAAc,KAAM+D,OAAO9C,GAK3B6E,GAAgB,IAAK,IAAK,IAAK,IAAK,KAAK/B,OAAO/D,GAChD+F,GAAmB,IAAK,IAAK,KAE7B1F,EAAsB,yBACtB2F,EAAoB,+BAEpBC,GACEC,YAAY,EACZC,eAAe,GAGjBC,GACEF,YAAY,EACZC,eAAe,GAGjBE,GACEC,MAAM,EACNC,OAAO,EACPC,KAAK,EACLC,QAAQ,EACRC,MAAM,EACNC,SAAS,EACTC,UAAU,EACVC,QAAQ,EACRC,WAAW,EACXC,SAAS,GAEXC,EAAc7F,QAAQ,cAU1BP,GAAIgF,UAAUjB,MAAQ,SAAU/D,EAAKG,EAAkBwC,GACrD,IAAKnC,EAAKiC,SAASzC,GACjB,KAAM,IAAI0C,WAAU,+CAAkD1C,GAMxE,IAAID,GAAaC,EAAIqG,QAAQ,KACzB/F,GACqB,IAAhBP,GAAqBA,EAAaC,EAAIqG,QAAQ,KAAQ,IAAM,IACjEnG,EAASF,EAAI4C,MAAMtC,GACnBK,EAAa,KACjBT,GAAO,GAAKA,EAAO,GAAG4B,QAAQnB,EAAY,KAC1CX,EAAME,EAAO2C,KAAKvC,EAElB,IAAI4B,GAAOlC,CAMX,IAFAkC,EAAOA,EAAKoE,QAEP3D,GAA+C,IAA1B3C,EAAI4C,MAAM,KAAK/B,OAAc,CAErD,GAAIR,GAAa0B,EAAkBN,KAAKS,EACxC,IAAI7B,EAiBF,MAhBAR,MAAKiF,KAAO5C,EACZrC,KAAKkF,KAAO7C,EACZrC,KAAKgF,SAAWxE,EAAW,GACvBA,EAAW,IACbR,KAAK8E,OAAStE,EAAW,GAEvBR,KAAK+E,MADHzE,EACWiG,EAAYrC,MAAMlE,KAAK8E,OAAOrC,OAAO,IAGrCzC,KAAK8E,OAAOrC,OAAO,IAG3BnC,IACPN,KAAK8E,OAAS,GACd9E,KAAK+E,UAEA/E,KAIX,GAAI0G,GAAQtG,EAAgBwB,KAAKS,EACjC,IAAIqE,EAAO,CACTA,EAAQA,EAAM,EACd,IAAIC,GAAaD,EAAMhE,aACvB1C,MAAKuE,SAAWoC,EAChBtE,EAAOA,EAAKI,OAAOiE,EAAM1F,QAO3B,GAAI8B,GAAqB4D,GAASrE,EAAKuE,MAAM,wBAAyB,CACpE,GAAIC,GAAgC,OAAtBxE,EAAKI,OAAO,EAAG,IACzBoE,GAAaH,GAASf,EAAiBe,KACzCrE,EAAOA,EAAKI,OAAO,GACnBzC,KAAKwE,SAAU,GAInB,IAAKmB,EAAiBe,KACjBG,GAAYH,IAAUd,EAAgBc,IAAU,CAmBnD,IAAK,GADDI,IAAW,EACNC,EAAI,EAAGA,EAAIzB,EAAgBtE,OAAQ+F,IAAK,CAC/C,GAAIC,GAAM3E,EAAKmE,QAAQlB,EAAgByB,KAC1B,IAATC,KAA4B,IAAbF,GAAkBE,EAAMF,KAAYA,EAAUE,GAKnE,GAAIC,GAAMC,CAGRA,IAFe,IAAbJ,EAEOzE,EAAK8E,YAAY,KAKjB9E,EAAK8E,YAAY,IAAKL,IAKjB,IAAZI,IACFD,EAAO5E,EAAKV,MAAM,EAAGuF,GACrB7E,EAAOA,EAAKV,MAAMuF,EAAS,GAC3BlH,KAAKyE,KAAO2C,mBAAmBH,IAIjCH,GAAW,CACX,KAAK,GAAIC,GAAI,EAAGA,EAAI1B,EAAarE,OAAQ+F,IAAK,CAC5C,GAAIC,GAAM3E,EAAKmE,QAAQnB,EAAa0B,KACvB,IAATC,KAA4B,IAAbF,GAAkBE,EAAMF,KAAYA,EAAUE,IAGlD,IAAbF,IAAkBA,EAAUzE,EAAKrB,QAErChB,KAAK0E,KAAOrC,EAAKV,MAAM,EAAGmF,GAC1BzE,EAAOA,EAAKV,MAAMmF,GAGlB9G,KAAKqH,YAILrH,KAAK4E,SAAW5E,KAAK4E,UAAY,EAIjC,IAAI0C,GAAoC,MAArBtH,KAAK4E,SAAS,IACe,MAA5C5E,KAAK4E,SAAS5E,KAAK4E,SAAS5D,OAAS,EAGzC,KAAKsG,EAEH,IAAK,GADDC,GAAYvH,KAAK4E,SAAS7B,MAAM,MAC3BgE,EAAI,EAAGS,EAAID,EAAUvG,OAAQ+F,EAAIS,EAAGT,IAAK,CAChD,GAAIU,GAAOF,EAAUR,EACrB,IAAKU,IACAA,EAAKb,MAAMhH,GAAsB,CAEpC,IAAK,GADD8H,GAAU,GACLC,EAAI,EAAGC,EAAIH,EAAKzG,OAAQ2G,EAAIC,EAAGD,IAClCF,EAAKI,WAAWF,GAAK,IAIvBD,GAAW,IAGXA,GAAWD,EAAKE,EAIpB,KAAKD,EAAQd,MAAMhH,GAAsB,CACvC,GAAIkI,GAAaP,EAAU5F,MAAM,EAAGoF,GAChCgB,EAAUR,EAAU5F,MAAMoF,EAAI,GAC9BiB,EAAMP,EAAKb,MAAMrB,EACjByC,KACFF,EAAWpG,KAAKsG,EAAI,IACpBD,EAAQE,QAAQD,EAAI,KAElBD,EAAQ/G,SACVqB,EAAO,IAAM0F,EAAQ/E,KAAK,KAAOX,GAEnCrC,KAAK4E,SAAWkD,EAAW9E,KAAK,IAChC,SAMJhD,KAAK4E,SAAS5D,OAlND,IAmNfhB,KAAK4E,SAAW,GAIhB5E,KAAK4E,SAAW5E,KAAK4E,SAASlC,cAG3B4E,IAKHtH,KAAK4E,SAAWrE,EAAS2H,QAAQlI,KAAK4E,UAGxC,IAAIuD,GAAInI,KAAK2E,KAAO,IAAM3E,KAAK2E,KAAO,GAClCyD,EAAIpI,KAAK4E,UAAY,EACzB5E,MAAK0E,KAAO0D,EAAID,EAChBnI,KAAKkF,MAAQlF,KAAK0E,KAId4C,IACFtH,KAAK4E,SAAW5E,KAAK4E,SAASnC,OAAO,EAAGzC,KAAK4E,SAAS5D,OAAS,GAC/C,MAAZqB,EAAK,KACPA,EAAO,IAAMA,IAOnB,IAAKmD,EAAemB,GAKlB,IAAK,GAAII,GAAI,EAAGS,EAAIjI,EAAWyB,OAAQ+F,EAAIS,EAAGT,IAAK,CACjD,GAAIsB,GAAK9I,EAAWwH,EACpB,KAA0B,IAAtB1E,EAAKmE,QAAQ6B,GAAjB,CACA,GAAIC,GAAMC,mBAAmBF,EACzBC,KAAQD,IACVC,EAAME,OAAOH,IAEfhG,EAAOA,EAAKU,MAAMsF,GAAIrF,KAAKsF,IAM/B,GAAIG,GAAOpG,EAAKmE,QAAQ,MACV,IAAViC,IAEFzI,KAAK6E,KAAOxC,EAAKI,OAAOgG,GACxBpG,EAAOA,EAAKV,MAAM,EAAG8G,GAEvB,IAAIC,GAAKrG,EAAKmE,QAAQ,IAqBtB,KApBY,IAARkC,GACF1I,KAAK8E,OAASzC,EAAKI,OAAOiG,GAC1B1I,KAAK+E,MAAQ1C,EAAKI,OAAOiG,EAAK,GAC1BpI,IACFN,KAAK+E,MAAQwB,EAAYrC,MAAMlE,KAAK+E,QAEtC1C,EAAOA,EAAKV,MAAM,EAAG+G,IAEdpI,IAEPN,KAAK8E,OAAS,GACd9E,KAAK+E,UAEH1C,IAAQrC,KAAKgF,SAAW3C,GACxBuD,EAAgBe,IAChB3G,KAAK4E,WAAa5E,KAAKgF,WACzBhF,KAAKgF,SAAW,KAIdhF,KAAKgF,UAAYhF,KAAK8E,OAAQ,CAChC,GAAIqD,GAAInI,KAAKgF,UAAY,GACrB2D,EAAI3I,KAAK8E,QAAU,EACvB9E,MAAKiF,KAAOkD,EAAIQ,EAKlB,MADA3I,MAAKkF,KAAOlF,KAAK4D,SACV5D,MAcTG,EAAIgF,UAAUvB,OAAS,WACrB,GAAIzD,GAAOH,KAAKyE,MAAQ,EACpBtE,KACFA,EAAOoI,mBAAmBpI,GAC1BA,EAAOA,EAAK8B,QAAQ,OAAQ,KAC5B9B,GAAQ,IAGV,IAAIG,GAAWN,KAAKuE,UAAY,GAC5BzB,EAAW9C,KAAKgF,UAAY,GAC5B9E,EAAOF,KAAK6E,MAAQ,GACpBpE,GAAO,EACPJ,EAAQ,EAERL,MAAK0E,KACPjE,EAAON,EAAOH,KAAK0E,KAEZ1E,KAAK4E,WACZnE,EAAON,IAAwC,IAAhCH,KAAK4E,SAAS4B,QAAQ,KACjCxG,KAAK4E,SACL,IAAM5E,KAAK4E,SAAW,KACtB5E,KAAK2E,OACPlE,GAAQ,IAAMT,KAAK2E,OAInB3E,KAAK+E,OACLpE,EAAKkD,SAAS7D,KAAK+E,QACnB6D,OAAOC,KAAK7I,KAAK+E,OAAO/D,SAC1BX,EAAQkG,EAAYuC,UAAU9I,KAAK+E,OAGrC,IAAIxE,GAASP,KAAK8E,QAAWzE,GAAU,IAAMA,GAAW,EAuBxD,OArBIC,IAAoC,MAAxBA,EAASmC,QAAQ,KAAcnC,GAAY,KAIvDN,KAAKwE,WACHlE,GAAYsF,EAAgBtF,MAAuB,IAATG,GAC9CA,EAAO,MAAQA,GAAQ,IACnBqC,GAAmC,MAAvBA,EAASwB,OAAO,KAAcxB,EAAW,IAAMA,IAEvDrC,IACRA,EAAO,IAGLP,GAA2B,MAAnBA,EAAKoE,OAAO,KAAcpE,EAAO,IAAMA,GAC/CK,GAA+B,MAArBA,EAAO+D,OAAO,KAAc/D,EAAS,IAAMA,GAEzDuC,EAAWA,EAASb,QAAQ,QAAS,SAAU9B,GAC7C,MAAOoI,oBAAmBpI,KAE5BI,EAASA,EAAO0B,QAAQ,IAAK,OAEtB3B,EAAWG,EAAOqC,EAAWvC,EAASL,GAO/CC,EAAIgF,UAAU7C,QAAU,SAAUnC,GAChC,MAAOH,MAAKoF,cAAc9E,EAASH,GAAU,GAAO,IAAOyD,UAQ7DzD,EAAIgF,UAAUC,cAAgB,SAAU9E,GACtC,GAAIK,EAAKiC,SAAStC,GAAW,CAC3B,GAAIwC,GAAM,GAAI3C,EACd2C,GAAIoB,MAAM5D,GAAU,GAAO,GAC3BA,EAAWwC,EAKb,IAAK,GAFD5C,GAAS,GAAIC,GACbM,EAAQmI,OAAOC,KAAK7I,MACfK,EAAK,EAAGA,EAAKI,EAAMO,OAAQX,IAAM,CACxC,GAAIE,GAAOE,EAAMJ,EACjBH,GAAOK,GAAQP,KAAKO,GAQtB,GAHAL,EAAO2E,KAAOvE,EAASuE,KAGD,KAAlBvE,EAAS4E,KAEX,MADAhF,GAAOgF,KAAOhF,EAAO0D,SACd1D,CAIT,IAAII,EAASkE,UAAYlE,EAASiE,SAAU,CAG1C,IAAK,GADDnE,GAAQwI,OAAOC,KAAKvI,GACfQ,EAAK,EAAGA,EAAKV,EAAMY,OAAQF,IAAM,CACxC,GAAIoB,GAAO9B,EAAMU,EACJ,cAAToB,IAAuBhC,EAAOgC,GAAQ5B,EAAS4B,IAUrD,MANI0D,GAAgB1F,EAAOqE,WACvBrE,EAAO0E,WAAa1E,EAAO8E,WAC7B9E,EAAO+E,KAAO/E,EAAO8E,SAAW,KAGlC9E,EAAOgF,KAAOhF,EAAO0D,SACd1D,EAGT,GAAII,EAASiE,UAAYjE,EAASiE,WAAarE,EAAOqE,SAAU,CAS9D,IAAKqB,EAAgBtF,EAASiE,UAAW,CAEvC,IAAK,GADDlC,GAAOuG,OAAOC,KAAKvI,GACdE,EAAI,EAAGA,EAAI6B,EAAKrB,OAAQR,IAAK,CACpC,GAAIjB,GAAI8C,EAAK7B,EACbN,GAAOX,GAAKe,EAASf,GAGvB,MADAW,GAAOgF,KAAOhF,EAAO0D,SACd1D,EAIT,GADAA,EAAOqE,SAAWjE,EAASiE,SACtBjE,EAASoE,MAASiB,EAAiBrF,EAASiE,UAU/CrE,EAAO8E,SAAW1E,EAAS0E,aAV+B,CAE1D,IADA,GAAIK,IAAW/E,EAAS0E,UAAY,IAAIjC,MAAM,KACvCsC,EAAQrE,UAAYV,EAASoE,KAAOW,EAAQ0D,WAC9CzI,EAASoE,OAAQpE,EAASoE,KAAO,IACjCpE,EAASsE,WAAYtE,EAASsE,SAAW,IAC3B,KAAfS,EAAQ,IAAaA,EAAQ4C,QAAQ,IACrC5C,EAAQrE,OAAS,GAAKqE,EAAQ4C,QAAQ,IAC1C/H,EAAO8E,SAAWK,EAAQrC,KAAK,KAYjC,GAPA9C,EAAO4E,OAASxE,EAASwE,OACzB5E,EAAO6E,MAAQzE,EAASyE,MACxB7E,EAAOwE,KAAOpE,EAASoE,MAAQ,GAC/BxE,EAAOuE,KAAOnE,EAASmE,KACvBvE,EAAO0E,SAAWtE,EAASsE,UAAYtE,EAASoE,KAChDxE,EAAOyE,KAAOrE,EAASqE,KAEnBzE,EAAO8E,UAAY9E,EAAO4E,OAAQ,CACpC,GAAIQ,GAAIpF,EAAO8E,UAAY,GACvBpF,EAAIM,EAAO4E,QAAU,EACzB5E,GAAO+E,KAAOK,EAAI1F,EAIpB,MAFAM,GAAOsE,QAAUtE,EAAOsE,SAAWlE,EAASkE,QAC5CtE,EAAOgF,KAAOhF,EAAO0D,SACd1D,EAGT,GAAIqF,GAAerF,EAAO8E,UAA0C,MAA9B9E,EAAO8E,SAASV,OAAO,GACzDkB,EACElF,EAASoE,MACPpE,EAAS0E,UAA4C,MAAhC1E,EAAS0E,SAASV,OAAO,GAElDiC,EAAcf,GAAYD,GACXrF,EAAOwE,MAAQpE,EAAS0E,SACvC0B,EAAgBH,EAChBI,EAAUzG,EAAO8E,UAAY9E,EAAO8E,SAASjC,MAAM,SACnDsC,EAAU/E,EAAS0E,UAAY1E,EAAS0E,SAASjC,MAAM,SACvD8D,EAAY3G,EAAOqE,WAAaqB,EAAgB1F,EAAOqE,SA2B3D,IApBIsC,IACF3G,EAAO0E,SAAW,GAClB1E,EAAOyE,KAAO,KACVzE,EAAOwE,OACU,KAAfiC,EAAQ,GAAaA,EAAQ,GAAKzG,EAAOwE,KACtCiC,EAAQsB,QAAQ/H,EAAOwE,OAEhCxE,EAAOwE,KAAO,GACVpE,EAASiE,WACXjE,EAASsE,SAAW,KACpBtE,EAASqE,KAAO,KACZrE,EAASoE,OACQ,KAAfW,EAAQ,GAAaA,EAAQ,GAAK/E,EAASoE,KACxCW,EAAQ4C,QAAQ3H,EAASoE,OAElCpE,EAASoE,KAAO,MAElB6B,EAAaA,IAA8B,KAAflB,EAAQ,IAA4B,KAAfsB,EAAQ,KAGvDnB,EAEFtF,EAAOwE,KAAQpE,EAASoE,MAA0B,KAAlBpE,EAASoE,KACrCpE,EAASoE,KAAOxE,EAAOwE,KAC3BxE,EAAO0E,SAAYtE,EAASsE,UAAkC,KAAtBtE,EAASsE,SAC7CtE,EAASsE,SAAW1E,EAAO0E,SAC/B1E,EAAO4E,OAASxE,EAASwE,OACzB5E,EAAO6E,MAAQzE,EAASyE,MACxB4B,EAAUtB,MAGP,IAAIA,EAAQrE,OAGV2F,IAAWA,MAChBA,EAAQlF,MACRkF,EAAUA,EAAQrD,OAAO+B,GACzBnF,EAAO4E,OAASxE,EAASwE,OACzB5E,EAAO6E,MAAQzE,EAASyE,UAErB,KAAKpE,EAAKqI,kBAAkB1I,EAASwE,QAAS,CAIjD,GAAI+B,EAAW,CACb3G,EAAO0E,SAAW1E,EAAOwE,KAAOiC,EAAQoC,OAIxC,IAAIjC,MAAa5G,EAAOwE,MAAQxE,EAAOwE,KAAK8B,QAAQ,KAAO,IACvDtG,EAAOwE,KAAK3B,MAAM,IAClB+D,KACF5G,EAAOuE,KAAOqC,EAAWiC,QACzB7I,EAAOwE,KAAOxE,EAAO0E,SAAWkC,EAAWiC,SAW/C,MARA7I,GAAO4E,OAASxE,EAASwE,OACzB5E,EAAO6E,MAAQzE,EAASyE,MAEnBpE,EAAKsI,OAAO/I,EAAO8E,WAAcrE,EAAKsI,OAAO/I,EAAO4E,UACvD5E,EAAO+E,MAAQ/E,EAAO8E,SAAW9E,EAAO8E,SAAW,KACpC9E,EAAO4E,OAAS5E,EAAO4E,OAAS,KAEjD5E,EAAOgF,KAAOhF,EAAO0D,SACd1D,EAGT,IAAKyG,EAAQ3F,OAYX,MATAd,GAAO8E,SAAW,KAEd9E,EAAO4E,OACT5E,EAAO+E,KAAO,IAAM/E,EAAO4E,OAG3B5E,EAAO+E,KAAO,KAEhB/E,EAAOgF,KAAOhF,EAAO0D,SACd1D,CAcT,KAAK,GARD6G,GAAOJ,EAAQhF,OAAO,GAAG,GACzBqF,GACD9G,EAAOwE,MAAQpE,EAASoE,QAAmB,MAATqC,GAAyB,OAATA,IACxC,KAATA,EAIAE,EAAK,EACAC,EAAIP,EAAQ3F,OAAQkG,GAAK,EAAGA,IACnCH,EAAOJ,EAAQO,GACF,MAATH,EACFJ,EAAQuC,OAAOhC,EAAG,GAEF,OAATH,GACPJ,EAAQuC,OAAOhC,EAAG,GAClBD,KAEOA,IACPN,EAAQuC,OAAOhC,EAAG,GAClBD,IAKJ,KAAKV,IAAeG,EAClB,KAAOO,IAAMA,EACXN,EAAQsB,QAAQ,OAIhB1B,GAA6B,KAAfI,EAAQ,IACpBA,EAAQ,IAA+B,MAAzBA,EAAQ,GAAGrC,OAAO,IACpCqC,EAAQsB,QAAQ,IAGdjB,GAAsD,MAAjCL,EAAQ3D,KAAK,KAAKP,QAAQ,IACjDkE,EAAQjF,KAAK,GAGf,IAAI4F,GAA4B,KAAfX,EAAQ,IACpBA,EAAQ,IAA+B,MAAzBA,EAAQ,GAAGrC,OAAO,EAGrC,IAAIuC,EAAW,CACb3G,EAAO0E,SAAW1E,EAAOwE,KAAO4C,EAAa,GACzCX,EAAQ3F,OAAS2F,EAAQoC,QAAU,EAIvC,IAAIjC,MAAa5G,EAAOwE,MAAQxE,EAAOwE,KAAK8B,QAAQ,KAAO,IACvDtG,EAAOwE,KAAK3B,MAAM,IAClB+D,KACF5G,EAAOuE,KAAOqC,EAAWiC,QACzB7I,EAAOwE,KAAOxE,EAAO0E,SAAWkC,EAAWiC,SA0B/C,MAtBAxC,GAAaA,GAAerG,EAAOwE,MAAQiC,EAAQ3F,OAE/CuF,IAAee,GACjBX,EAAQsB,QAAQ,IAGbtB,EAAQ3F,OAKXd,EAAO8E,SAAW2B,EAAQ3D,KAAK,MAJ/B9C,EAAO8E,SAAW,KAClB9E,EAAO+E,KAAO,MAOXtE,EAAKsI,OAAO/I,EAAO8E,WAAcrE,EAAKsI,OAAO/I,EAAO4E,UACvD5E,EAAO+E,MAAQ/E,EAAO8E,SAAW9E,EAAO8E,SAAW,KACpC9E,EAAO4E,OAAS5E,EAAO4E,OAAS,KAEjD5E,EAAOuE,KAAOnE,EAASmE,MAAQvE,EAAOuE,KACtCvE,EAAOsE,QAAUtE,EAAOsE,SAAWlE,EAASkE,QAC5CtE,EAAOgF,KAAOhF,EAAO0D,SACd1D,GAGTC,EAAIgF,UAAUkC,UAAY,WACxB,GAAIlH,GAAOH,KAAK0E,KACZpE,EAAOQ,EAAYc,KAAKzB,EACxBG,KACFA,EAAOA,EAAK,GACC,MAATA,IACFN,KAAK2E,KAAOrE,EAAKmC,OAAO,IAE1BtC,EAAOA,EAAKsC,OAAO,EAAGtC,EAAKa,OAASV,EAAKU,SAEvCb,IAAQH,KAAK4E,SAAWzE,sHClvBhC,YAsBA,SAASF,UAAUE,EAAGQ,GAEpB,GAAIR,YAAaF,UACf,MAAOE,GAAEgJ,MAAMxI,EAGjBR,GAAIiJ,KAAKC,SAASlJ,EAClB,IAAIE,GAAO+I,KAAKE,QAAQnJ,EAExB,OAAIE,GAAKkJ,MACA,GAAItJ,UAASsB,IAAIpB,EAAGQ,GAEpBN,EAAKmJ,UACL,GAAIvJ,UAASmB,QAAQjB,EAAGQ,GAGxB,GAAIV,UAASiB,MAAMf,EAAGQ,GAiiBjC,QAAS8I,oBAAoBtJ,EAAQQ,GACnC,GAAIN,GAAO+I,KAAKE,QAAQ3I,EAAK,GAC7B,OAAIN,GAAKkJ,MACAtJ,SAASsB,IAAIpB,GAAQuJ,MAAMzJ,SAASsB,IAAKZ,GAEzCN,EAAKmJ,UACLvJ,SAASmB,QAAQjB,GAAQuJ,MAAMzJ,SAASmB,QAAST,GAGjDV,SAASiB,MAAMf,GAAQuJ,MAAMzJ,SAASiB,MAAOP,GA9kBxDlB,OAAOD,QAAUS,QAEjB,IAAIgF,MAAOvE,QAAQ,eACfc,IAAMd,QAAQ,cACd0I,KAAO1I,QAAQ,UACfiJ,YAAcjJ,QAAQ,eACtBkJ,OAAS,WAAY,UAAW,WAAY,OAAQ,OAAQ,MAAO,OACjE,WAAY,QAAS,SAAU,OAAQ,SAkC5C,QAAS,UAAW,aAAaC,QAAQ,SAAU1J,GAClDF,SAASE,GAAQ,SAAUQ,GACzB,MAAIA,aAAaV,UACRU,EAAER,KAEFiJ,KAAKE,QAAQ3I,GAAGR,MAK7BiJ,KAAKU,MAAMD,QAAQ,SAAU1J,OACJ,KAAnBF,SAASE,KACXF,SAASE,GAAQ,SAAUQ,EAAGN,GAG5B,MADe,IADHL,MACaW,EAAGN,GACZF,OActBF,SAASwD,QAAU,SAAUtD,EAAGQ,GAG9B,MADe,IADHX,MACaG,EAAGQ,GACZ8C,WAUlBxD,SAASkF,UAAU1B,QAAU,WAC3B,MAAOzD,MAAK+J,MAAMtG,QAAQzD,KAAKgF,WAajC/E,SAASyD,SAAW,SAAUvD,EAAGQ,EAAKN,GAOpC,MANqB,gBAAVM,KACTN,EAAUM,EACVA,MAAM,IAGO,GADHX,MACaG,EAAGE,GACZqD,SAAS/C,IAW3BV,SAASkF,UAAUzB,SAAW,SAAUvD,GACtC,MAAOH,MAAK+J,MAAMrG,SAAS1D,KAAKgE,KAAM7D,IAYxCF,SAAS0D,QAAU1D,SAASkE,IAS5BlE,SAASkF,UAAUxB,QAAU,WAC3B,MAAO3D,MAAKmE,KAadlE,SAAS+C,KAAO,SAAU7C,EAAGQ,GAC3B,MAAO8I,oBAAmB,OAAQlH,YAYpCtC,SAASkF,UAAUnC,KAAO,SAAU7C,EAAGQ,GACrC,GAAIN,IAAQL,MAAMsD,OAAO0G,MAAM7E,UAAUxD,MAAMZ,KAAKwB,YAChDnC,EAASgJ,KAAKa,UAAU5J,GAAM,GAAO,EAMzC,OALaL,MAAK+J,MAAM/G,KAAK0G,MAAM1J,KAAK+J,MAAO3J,EAAO8J,WAGrC9J,EAAO+J,SAAS/J,EAAOgK,MACzBhK,EAAOiK,OAAOjK,EAAOgK,OAetCnK,SAASqC,QAAU,SAAUnC,EAAMQ,EAAIN,GACrC,MAAOoJ,oBAAmB,UAAWlH,YAavCtC,SAASkF,UAAU7C,QAAU,SAAUnC,EAAIQ,GACzC,GAAIN,IAAQL,MAAMsD,OAAO0G,MAAM7E,UAAUxD,MAAMZ,KAAKwB,YAChDnC,EAASgJ,KAAKa,UAAU5J,GACxBI,EAAYL,EAAO8J,SAEvB,IAAI9J,EAAOkK,QAET,MAAOrK,UAASsB,IAAIe,QAAQoH,MAAMzJ,SAASsB,IAAKnB,EAAOmK,MAGrDpI,SAAQqI,UAEV/J,GAAaR,SAAS0C,OAAOW,OAAOlD,EAAO8J,WAQ7C,KAAK,GAJD5J,GAAWN,KAAK+J,MAAMzH,QAAQoH,MAAM1J,KAAK+J,MAAOtJ,GAGhDP,EAAS,GAAI4C,EAAO,GACfvC,EAAI,EAAGA,GAAKH,EAAOgK,KAAM7J,IAC5BH,EAAO+J,SAAS5J,IAClBL,EAASE,EAAO+J,SAAS5J,GACzBuC,EAAO1C,EAAOiK,OAAO9J,IAEdH,EAAOiK,OAAO9J,KACrBuC,EAAO1C,EAAOiK,OAAO9J,GAIzB,OAAOD,GAAWJ,EAAS4C,GAa7B7C,SAASgD,UAAY,SAAU9C,EAAGQ,GAEhC,MAAO,IADKX,MACKG,EAAGQ,GAASsC,aAW/BhD,SAASkF,UAAUlC,UAAY,WAC7B,GAAI9C,GAAYH,KAAKgF,UAAYhF,KAAK+J,MAAMnG,OAAO5D,KAGnD,OAFiBA,MAAK+J,MAAM9G,UAAU9C,GAClBH,KAAKyK,8BAc3BxK,SAAS2D,OAAS,SAAUzD,EAAGQ,GAE7B,MAAO,IADKX,MACKG,EAAGQ,GAASiD,UAW/B3D,SAASkF,UAAUvB,OAAS,WAG1B,MAFe5D,MAAK+J,MAAMnG,OAAO5D,MACbA,KAAKyK,8BAoB3BxK,SAASyK,WAAa,SAAUvK,EAAGQ,EAAMN,GAEvC,MAAO,IADKL,MACKG,EAAGE,GAASqK,WAAW/J,IAa1CV,SAASkF,UAAUuF,WAAa,SAAUvK,GACxCA,EAAOyJ,MAAMpD,QAAQrG,EACrB,IAAIQ,GAAQX,KAAKmJ,OAajB,OAZAhJ,GAAO,IAAMQ,EAAM4D,SAAW,IAC9BpE,EAAO,IAAMQ,EAAM6D,SAAU,GAC7BrE,EAAO,IAAMQ,EAAMiE,SAAW,IAC9BzE,EAAO,IAAMQ,EAAMgE,KAAO,IAC1BxE,EAAO,IAAMQ,EAAM+D,KAAO,IAC1BvE,EAAO,IAAMQ,EAAMoD,IAAM,IACzB5D,EAAO,IAAMQ,EAAMqD,KAAO,IAC1B7D,EAAO,IAAMQ,EAAMqE,SAAW,IAC9B7E,EAAO,IAAMQ,EAAMoE,MAAQ,IAC3B5E,EAAO,IAAMQ,EAAMmE,OAAS,IAC5B3E,EAAO,KAAOQ,EAAMsE,KAAO,IAC3B9E,EAAO,KAAOQ,EAAMkE,KAAO,IACpBlE,EAAMiD,UAQf3D,SAASkF,UAAUkE,SAAWpJ,SAASkF,UAAUvB,OAOjD3D,SAASkF,UAAUwF,QAAU1K,SAASkF,UAAUvB,OAShD3D,SAAS2K,MAAQ,SAAUzK,EAAGQ,GAE5B,MAAO,IADKX,MACKG,EAAGQ,GAASiK,SAS/B3K,SAASkF,UAAUyF,MAAQ,WACzB,MAAOpJ,KAAI0C,MAAMlE,KAAK6K,eAAe,IAUvC5K,SAAS4K,YAAc,SAAU1K,EAAGQ,GAElC,MAAO,IADKX,MACKG,EAAGQ,GAASkK,eAS/B5K,SAASkF,UAAU0F,YAAc,WAC/B,GAAI1K,GAAWH,KAAK4E,SAChBjE,EAAWX,KAAKgF,SAChB3E,EAASL,KAAK8E,OACd1E,EAAOJ,KAAK6E,IAGhBlE,GAAWA,EAASsB,QAAQmH,KAAK0B,iBAAkB,OACnDzK,EAASA,EAAO4B,QAAQmH,KAAK0B,iBAAkB,OAC/C1K,EAAOA,EAAK6B,QAAQmH,KAAK0B,iBAAkB,MAG3C,IAAIrK,GAAYe,IAAIoC,QAClBW,SAAU,QACVC,SAAS,EACTI,SAAUzE,EACV6E,SAAUrE,EACVmE,OAAQzE,EACRwE,KAAMzE,GASR,OALaoB,KAAI0C,MAAMzD,GAIFmD,UAavB3D,SAAS0C,IAAM,WACb,GAAIR,QAAQqI,QAAS,CACnB,GAAIrK,GAAI,GAAIF,UAASsB,IAAI1B,OAAOkL,SAAS7F,MACrCvE,EAAMR,EAAEuK,WAAW,MAIvB,OAHI/J,GAAI8B,QAAQ,KAAOxC,SAASsB,IAAI0C,MAClCtD,GAAOV,SAASsB,IAAI0C,KAEftD,EAGP,MAAOwB,SAAQQ,MAAQsC,KAAKhB,KAehChE,SAASiE,MAAQ,SAAU/D,EAAGQ,GAE5B,MAAO,IADKX,MACKG,EAAGQ,IActBV,SAASkF,UAAUjB,MAAQ,SAAU/D,EAAGQ,GAEtC,MAAIR,aAAaH,MAAKgL,aACpB5B,KAAK6B,KAAK9K,EAAGH,WACbA,KAAKkL,SAAWvK,GAAWR,EAAE+K,UAAYlL,KAAKkL,YAKhDlL,KAAKuJ,OAAQ,EACbvJ,KAAKmL,MAAO,EACZnL,KAAKoL,SAAU,EACfpL,KAAKwJ,WAAY,EACjBxJ,KAAK8B,OAAQ,EACb9B,KAAK+B,YAAa,EAClB/B,KAAKiE,IAAM,GACXjE,KAAKqE,UAAY,GACjBrE,KAAKkF,KAAO,GACZlF,KAAKuE,SAAW,GAChBvE,KAAKwE,SAAU,EACfxE,KAAKyE,KAAO,GACZzE,KAAK0E,KAAO,GACZ1E,KAAK4E,SAAW,GAChB5E,KAAK2E,KAAO,GACZ3E,KAAKiF,KAAO,GACZjF,KAAKgF,SAAW,GAChBhF,KAAK8D,KAAO,GACZ9D,KAAK+D,IAAM,GACX/D,KAAKgE,KAAO,GACZhE,KAAKoE,KAAO,GACZpE,KAAKmE,IAAM,GACXnE,KAAK8E,OAAS,GACd9E,KAAK+E,SACL/E,KAAK6E,KAAO,GAGZ7E,KAAKkL,SAAWvK,GAAWX,KAAKkL,UAAa/K,GAAKA,EAAE+K,SAG7C9B,KAAKC,SAASlJ,KAQvBF,SAASkF,UAAUkG,OAAS,WAE1B,IAAK,GADDlL,MACKQ,EAAI,EAAGA,EAAIyI,KAAKU,MAAM9I,OAAQL,IAAK,CAC1C,GAAIN,GAAO+I,KAAKU,MAAMnJ,EACtBR,GAAKE,GAAQL,KAAKK,GAEpB,MAAOF,IASTF,SAASkF,UAAUgE,MAAQ,SAAUhJ,GAEnC,MAAO,KAAI,EADCH,KAAKgL,aACAhL,KAAMG,IAUzBF,SAASkF,UAAUsF,2BAA6B,WAC9C,GAAItK,GAASH,KAAK8E,QAAU,GACxBnE,EAAOX,KAAK6E,MAAQ,EAExB,IAAI1E,EACgB,MAAdA,EAAO,KACTA,EAAS,IAAMA,OAGd,IAAIH,KAAK+E,MAAO,CAEnB,GAAI1E,GAAQsJ,YAAYb,UAAU9I,KAAK+E,MACnC1E,KACFF,EAAS,IAAME,GASnB,MAJIM,IAAoB,MAAZA,EAAK,KACfA,EAAO,IAAMA,GAGRR,EAASQ,gJC7jBlB,YAaA,SAAS2K,WAAW3K,EAAGR,GACrB,KAAMH,eAAgBsL,YACpB,KAAM,IAAIzI,WAAU,oEAGtB7C,MAAK+J,MAAQ5I,MACbnB,KAAKkE,MAAMvD,EAAGR,GAjBhBV,OAAOD,QAAU8L,SAEjB,IAAInK,OAAQT,QAAQ,eAAeS,MAC/BlB,SAAWS,QAAQ,WACnB0I,KAAO1I,QAAQ,SAgBnB0I,MAAKmC,SAASD,UAAWrL,UACzBqL,UAAUrH,IAAM9C,MAAM8C,IACtBqH,UAAUjH,UAAYlD,MAAMkD,UAG5BiH,UAAU/B,MAAQ,WAAc,OAAO,GACvC+B,UAAUF,QAAU,WAAc,OAAO,GACzCE,UAAU9B,UAAY,WAAc,OAAO,GAQ3C8B,UAAUnG,UAAUjB,MAAQ,SAAUvD,EAAGR,GAEvC,GAAmB,iBADnBQ,EAAIV,SAASkF,UAAUjB,MAAMwF,MAAM1J,KAAMuC,YACZ,CAC3B,GAAIjC,GAAQ8I,KAAKoC,UAAU7K,EAAGX,KAAKkL,UAC/BhL,EAASiB,MAAM+C,MAAM5D,EAAM0E,SAE/BhF,MAAKmL,MAAO,EACZnL,KAAKoL,SAAU,EACfpL,KAAK+B,WAAaZ,MAAMY,WAAWzB,EAAM0E,UACzChF,KAAKiE,IAAM9C,MAAM8C,IACjBjE,KAAKqE,UAAYlD,MAAMkD,UACvBrE,KAAKkF,KAAOvE,EACZX,KAAKiF,KAAO3E,EAAM0E,SAAW1E,EAAMwE,OACnC9E,KAAKgF,SAAW1E,EAAM0E,SACtBhF,KAAK8D,KAAO5D,EAAO4D,KACnB9D,KAAK+D,IAAM7D,EAAO6D,IAClB/D,KAAKgE,KAAO9D,EAAO8D,KACnBhE,KAAKoE,KAAOlE,EAAOkE,KACnBpE,KAAKmE,IAAMjE,EAAOiE,IAClBnE,KAAK8E,OAASxE,EAAMwE,OACpB9E,KAAK+E,MAAQzE,EAAMyE,MACnB/E,KAAK6E,KAAOvE,EAAMuE,KAEpB,MAAO7E,OAUTsL,UAAUtI,KAAO,SAAUrC,EAAGR,GAC5B,MAAOF,UAASkF,UAAUnC,KAAK0G,OAAQK,MAAO5I,MAAO+D,KAAM,IAAM3C,YAWnE+I,UAAUhJ,QAAU,SAAU3B,EAAMR,EAAIG,GACtC,MAAOL,UAASkF,UAAU7C,QAAQoH,OAAQK,MAAO5I,MAAO+D,KAAM,IAAM3C,YAQtE+I,UAAU3I,IAAM,WACd,GAAIhC,GAAMV,SAAS0C,KACnB,OAAOxB,OAAM8B,UAAUtC,mFC7FzB,YAgBA,SAAS8K,SAAStL,EAAGE,GACnB,KAAML,eAAgByL,UACpB,KAAM,IAAI5I,WAAU,kEAGtB7C,MAAK+J,MAAQ5I,MACbnB,KAAKkE,MAAM/D,EAAGE,GApBhBZ,OAAOD,QAAUiM,OAEjB,IAAItK,OAAQT,QAAQ,eAAeS,MAC/BK,IAAMd,QAAQ,cACdT,SAAWS,QAAQ,eACnB0I,KAAO1I,QAAQ,UACfgL,eAAiB,OACjBC,qBAAuB,iBAgB3BvC,MAAKmC,SAASE,QAASxL,UACvBwL,QAAQxH,IAAM9C,MAAM8C,IAGpBwH,QAAQlC,MAAQ,WAAc,OAAO,GACrCkC,QAAQL,QAAU,WAAc,OAAO,GACvCK,QAAQjC,UAAY,WAAc,OAAO,GAQzCiC,QAAQtG,UAAUjB,MAAQ,SAAU/D,EAAGE,GAErC,GAAmB,iBADnBF,EAAIF,SAASkF,UAAUjB,MAAMwF,MAAM1J,KAAMuC,YACZ,CAC3B,GAAI5B,GAAYa,IAAI0C,MAAM/D,GAAG,GACzBD,EAAaiB,MAAM+C,MAAMvD,EAAUqE,UAAY,GAEnDhF,MAAKuJ,OAAQ,EACbvJ,KAAK+B,aAAepB,EAAU4D,YAAc5D,EAAU+D,MAAQvD,MAAMY,WAAWpB,EAAUqE,UAAY,IACrGhF,KAAKiE,IAAM9C,MAAM8C,IACjBjE,KAAKkF,KAAOvE,EAAUuE,MAAQ,GAC9BlF,KAAKuE,SAAW5D,EAAU4D,UAAY,GACtCvE,KAAKwE,QAAU7D,EAAU6D,UAAW,EACpCxE,KAAKyE,KAAO9D,EAAU8D,MAAQ,GAC9BzE,KAAK0E,KAAO/D,EAAU+D,MAAQ,GAC9B1E,KAAK4E,SAAWjE,EAAUiE,UAAY,GACtC5E,KAAK2E,KAAOhE,EAAUgE,MAAQ,GAC9B3E,KAAKiF,KAAOtE,EAAUsE,MAAQ,GAC9BjF,KAAKgF,SAAWrE,EAAUqE,UAAY,GACtChF,KAAK8D,KAAO5D,EAAW4D,KACvB9D,KAAK+D,IAAM7D,EAAW6D,IACtB/D,KAAKgE,KAAO9D,EAAW8D,KACvBhE,KAAKoE,KAAOlE,EAAWkE,KACvBpE,KAAKmE,IAAMjE,EAAWiE,IACtBnE,KAAK8E,OAASnE,EAAUmE,QAAU,GAClC9E,KAAK+E,MAAQpE,EAAUoE,UACvB/E,KAAK6E,KAAOlE,EAAUkE,MAAQ,GAEhC,MAAO7E,OASTyL,QAAQtG,UAAUlC,UAAY,WAC5B,GAAI9C,GAAYH,KAAKgF,UAAYhF,KAAK4L,wBAClCvL,EAAac,MAAM8B,UAAU9C,GAE7BQ,GAAkB,CACH,OAAfN,IAEFA,EAAa,GACbM,GAAkB,EAGpB,IAAIT,GAAQF,KAAKmJ,OAIjB,OAHAjJ,GAAM8E,SAAW3E,EACjBF,EAAYqB,IAAIoC,OAAO1D,GAEL,KAAdC,GAAoBQ,EAEf,IAGAR,GASXsL,QAAQtG,UAAUvB,OAAS,WACzB,GAAIzD,GAAQH,KAAKmJ,OAEjB,OADAhJ,GAAM6E,SAAWhF,KAAK4L,wBACfpK,IAAIoC,OAAOzD,IAQpBsL,QAAQtG,UAAU0F,YAAc,WAC9B,MAAOrJ,KAAIoC,OAAO5D,OAUpByL,QAAQzI,KAAO,SAAU7C,EAAGE,GAI1B,IAAK,GAHDM,GAASyI,KAAKa,UAAU1H,WAAW,GACnCrC,EAASS,EAAOuJ,UAAU,GAErB5J,EAAI,EAAGA,EAAIK,EAAOuJ,UAAUlJ,OAAQV,IAAK,CAChD,GAAIF,GAAUO,EAAOuJ,UAAU5J,EAC3BF,KAEEA,IAAYe,MAAM8C,KAAmB,OAAZ7D,EAEvBE,IAAMK,EAAOuJ,UAAUlJ,OAAS,IAClCd,GAAUiB,MAAM8C,KAGXmF,KAAKyC,qBAAqB3L,IAAWkJ,KAAK0C,uBAAuB1L,GACxEF,GAAUE,EAGVF,GAAUiB,MAAM8C,IAAM7D,GAW5B,MAHAF,IAFiBS,EAAOwJ,SAASxJ,EAAOyJ,MACzBzJ,EAAO0J,OAAO1J,EAAOyJ,MAGtB,GAAIqB,SAAQvL,GACX+C,aAUjBwI,QAAQtG,UAAUnC,KAAO,SAAU7C,EAAGE,GACpC,MAAOoL,SAAQzI,KAAK0G,MAAM+B,SAAUzL,MAAMsD,OAAO0G,MAAM7E,UAAUxD,MAAMZ,KAAKwB,cAW9EkJ,QAAQnJ,QAAU,SAAUnC,EAAME,EAAIM,GACpC,GAAIT,GAAOkJ,KAAK2C,QAAQxJ,WACpBjC,EAAQJ,EAAK8L,KACjB3L,GAAK+I,KAAKC,SAAS/I,EAAMA,EAAMU,OAAS,GAExC,KAAK,GAAIZ,GAAIE,EAAMU,OAAS,EAAGZ,GAAK,EAAGA,IAIrC,GAHAD,EAAOiJ,KAAKC,SAAS/I,EAAMF,IAC3BC,EAAKmB,IAAIc,QAAQnC,EAAME,GAEnBsL,qBAAqBzI,KAAK7C,GAE5B,MAAOA,EAIX,OAAOmB,KAAIc,QAAQrC,SAAS0C,MAAOtC,IAUrCoL,QAAQtG,UAAU7C,QAAU,SAAUnC,EAAIE,GACxC,MAAOoL,SAAQnJ,QAAQoH,MAAM+B,SAAUzL,MAAMsD,OAAO0G,MAAM7E,UAAUxD,MAAMZ,KAAKwB,cAQjFkJ,QAAQ9I,IAAM,WACZ,GAAIxC,GAAMF,SAAS0C,KACnB,OAAO8I,SAAQxI,UAAU9C,IAS3BsL,QAAQtG,UAAUyG,sBAAwB,WACxC,GAAIzL,GAAWH,KAAKgF,QAEpB,IAAIhF,KAAK+D,KAAO/D,KAAKgE,KAAM,CACzB,GAAI3D,GAAcF,CAElB,IAAIH,KAAK+D,MAAQ/D,KAAKiE,IAAK,CAGzB9D,GADcuL,eAAe9J,KAAK5B,KAAKgF,YAAc,KAClC,GAAKhF,KAAKgE,SAG7B7D,GAAWgB,MAAMyC,OAAO5D,KAItBoJ,MAAKyC,qBAAqBxL,KAAiB+I,KAAKyC,qBAAqB1L,KACvEA,GAAYgB,MAAM8C,KAItB,MAAO9D,sGCnPT,YAeA,SAAS8L,aAAatL,EAAGR,GACvB,KAAMH,eAAgBiM,cACpB,KAAM,IAAIpJ,WAAU,sEAGtB7C,MAAK+J,MAAQzI,MACbtB,KAAKkE,MAAMvD,EAAGR,GAnBhBV,OAAOD,QAAUyM,WAEjB,IAAI3K,OAAQZ,QAAQ,eAAeY,MAC/BrB,SAAWS,QAAQ,WACnB0I,KAAO1I,QAAQ,UACfwL,WAAa,sCACbC,gBAAkB,kBAgBtB/C,MAAKmC,SAASU,YAAahM,UAC3BgM,YAAYhI,IAAM3C,MAAM2C,IACxBgI,YAAY5H,UAAY/C,MAAM+C,UAG9B4H,YAAY1C,MAAQ,WAAc,OAAO,GACzC0C,YAAYb,QAAU,WAAc,OAAO,GAC3Ca,YAAYzC,UAAY,WAAc,OAAO,GAQ7CyC,YAAY9G,UAAUjB,MAAQ,SAAUvD,EAAGR,GAEzC,GAAmB,iBADnBQ,EAAIV,SAASkF,UAAUjB,MAAMwF,MAAM1J,KAAMuC,YACZ,CAC3B,GAAInC,GAAQgJ,KAAKoC,UAAU7K,EAAGX,KAAKkL,UAC/B5K,EAASgB,MAAM4C,MAAM9D,EAAM4E,UAC3B9E,EAAMgM,WAAWtK,KAAKxB,EAAM4E,SAEhChF,MAAKmL,MAAO,EACZnL,KAAKwJ,WAAY,EACjBxJ,KAAK+B,WAAaT,MAAMS,WAAW3B,EAAM4E,UACzChF,KAAK8B,QAAU5B,EACfF,KAAKiE,IAAM3C,MAAM2C,IACjBjE,KAAKqE,UAAY/C,MAAM+C,UACvBrE,KAAKkF,KAAOvE,EACZX,KAAKiF,KAAO7E,EAAM4E,SAAW5E,EAAM0E,OACnC9E,KAAKgF,SAAW5E,EAAM4E,SACtBhF,KAAK8D,KAAOxD,EAAOwD,KACnB9D,KAAK+D,IAAMzD,EAAOyD,IAClB/D,KAAKgE,KAAO1D,EAAO0D,KACnBhE,KAAKoE,KAAO9D,EAAO8D,KACnBpE,KAAKmE,IAAM7D,EAAO6D,IAClBnE,KAAK8E,OAAS1E,EAAM0E,OACpB9E,KAAK+E,MAAQ3E,EAAM2E,MACnB/E,KAAK6E,KAAOzE,EAAMyE,KAEd7E,KAAK8B,QAEP9B,KAAK0E,KAAO1E,KAAK4E,SAAW1E,EAAI,IAGpC,MAAOF,OAQTiM,YAAY9G,UAAUvB,OAAS,WAC7B,OAAI5D,KAAK8B,QAAU9B,KAAK0E,OAAQ1E,KAAK4E,UAAc5E,KAAK+D,KAAQ/D,KAAKgE,KAI9D/D,SAASkF,UAAUvB,OAAO8F,MAAM1J,KAAMuC,WAFpC,QAAUvC,KAAK4E,UAAY5E,KAAK0E,OAU3CuH,YAAY9G,UAAU0F,YAAc,WAClC,GAAIlK,GAAQX,KAAKmJ,OAKjB,IAFAxI,EAAMqE,SAAWrE,EAAMqE,SAAS/C,QAAQmH,KAAK0B,iBAAkB,KAE3D9K,KAAK8B,MAAO,CACd,GAAI3B,GAAQgM,gBAAgBvK,KAAKjB,EAAMqE,SACnC7E,KACFQ,EAAMiE,SAAWzE,EAAM,GACvBQ,EAAMqE,SAAW7E,EAAM,IAAM,KAIjC,MAAOF,UAASkF,UAAU0F,YAAYnB,MAAM/I,EAAO4B,YAUrD0J,YAAYjJ,KAAO,SAAUrC,EAAGR,GAC9B,MAAOF,UAASkF,UAAUnC,KAAK0G,OAAQK,MAAOzI,MAAO4D,KAAM,IAAM3C,YAWnE0J,YAAY3J,QAAU,SAAU3B,EAAMR,EAAIC,GACxC,MAAOH,UAASkF,UAAU7C,QAAQoH,OAAQK,MAAOzI,MAAO4D,KAAM,IAAM3C,YAQtE0J,YAAYtJ,IAAM,WAChB,GAAIhC,GAAMV,SAAS0C,KACnB,OAAOrB,OAAM2B,UAAUtC,sGCzIzB,YAmCA,SAASiC,UAAUzC,GACjB,MAAwB,gBAAVA,GAShB,QAAS0D,UAAU1D,GACjB,MAAwB,gBAAVA,IAA8B,OAARA,EAStC,QAAS8I,QAAQ9I,GACf,MAAe,QAARA,EAST,QAAS6I,mBAAmB7I,GAC1B,MAAc,OAAPA,EAST,QAASkJ,UAAUlJ,GACjB,GAAmB,gBAARA,GACT,MAAOA,EAEJ,IAAIA,YAAaqB,KAAID,IACxB,MAAOpB,GAAEyD,QAEN,IAAIzD,YAAaF,UACpB,MAAOE,GAAEyD,QAEN,IAAIzD,GAAyB,gBAAZA,GAAM+E,KAC1B,MAAO/E,GAAE+E,IAGX,MAAM,IAAItE,OAAM,8CAAiDT,GAAM,IAAMA,GAS/E,QAASoL,UAAUpL,EAAOE,GACxBF,EAAMgF,UAAYyD,OAAOwD,OAAO/L,EAAM8E,WACtChF,EAAMgF,UAAU6F,YAAc7K,EAEVyI,OAAOC,KAAKxI,GAClBwJ,QAAQ,SAAU3J,GACO,kBAAzBG,GAAMH,GAChBC,EAAMD,GAAgB,WACpB,MAAOG,GAAMH,GAAcwJ,MAAMvJ,EAAOoC,YAI1CpC,EAAMD,GAAgBG,EAAMH,KAYlC,QAAS+K,MAAM9K,EAAKE,GAElB,IAAK,GAAIH,GAAI,EAAGA,EAAIkJ,KAAKU,MAAM9I,OAAQd,IAAK,CAC1C,GAAII,GAAO8I,KAAKU,MAAM5J,EACtBG,GAAKC,GAAQH,EAAIG,GAGnB,MAAOD,GAST,QAASiJ,SAASnJ,GAChB,MAAIA,aAAaF,UACRE,GAEe,gBAARA,KACdA,EAAIkJ,SAASlJ,IAMXkM,gBAAgBnJ,KAAK/C,IACdoJ,OAAO,GAIdpH,QAAQqI,SACDjB,OAAO,GAEY,UAArBpH,QAAQC,UACNoH,WAAW,IAGX4B,SAAS,IAWtB,QAASI,WAAWrL,EAAGE,GACrB,GAAIH,GAAO,GAAII,EAAS,GAAIF,IAG5B,IAFAC,EAAUA,MAENA,EAAQiM,cAAe,CAEzB,GAAI7L,GAAYN,EAAEqG,QAAQ,IACtB/F,IAAa,IACfP,EAAOC,EAAEsC,OAAOhC,GAChBN,EAAIA,EAAEsC,OAAO,EAAGhC,IAIpB,GAAIJ,EAAQkM,eAAgB,CAE1B,GAAI5L,GAAaR,EAAEgH,YAAY,IAC3BxG,IAAc,IAChBL,EAASH,EAAEsC,OAAO9B,GAClBP,EAAQE,EAAOmC,OAAO,IAClBpC,EAAQmM,sBAAiD,KAA7BnM,EAAQmM,oBACtCpM,EAAQuJ,YAAYzF,MAAM9D,IAE5BD,EAAIA,EAAEsC,OAAO,EAAG9B,IAIpB,OACEqE,SAAU7E,EACV2E,OAAQxE,EACRyE,MAAO3E,EACPyE,KAAM3E,GAYV,QAAS+J,WAAW9J,EAAME,EAAOH,GAC/BC,EAAO4L,QAAQ5L,EAcf,KAAK,GAbDG,GAAQH,EAAK6L,MACb5L,EAAUD,EAAKsM,QAEfhM,GACF2J,KAAM9J,EAAMU,OAAS,EACrBsJ,SAAS,EACTC,SACAL,aACAC,YACAE,WAIO1J,EAAI,EAAGA,EAAIL,EAAMU,OAAQL,IAAK,CACrC,GACIJ,GAAMO,EAAUgC,EAAQZ,EAAM1B,EAD9BjB,EAAOe,EAAMK,EAGbpB,aAAgBU,WAEdI,GAASd,EAAKgK,OAChB9I,EAAO6J,SAAU,EACjB/J,EAAOhB,EAAK2F,KACZpE,EAAWvB,EAAKmL,WAAW,aAG3BnK,EAAOO,EAAWvB,EAAKyF,SAEzBlC,EAASvD,EAAKuF,OACd5C,EAAO3C,EAAKsF,KAEF,IAANlE,GAAYP,IAGdA,EAAUb,EAAK2L,YAIjB3K,EAAO8I,SAAS9J,GAEZc,IAAWH,GAAQmM,gBAAgBnJ,KAAK3C,IAE1CE,EAAO6J,SAAU,EACjB9J,EAAagL,UAAUjL,GAAQgM,gBAAgB,EAAMD,eAAe,EAAME,kBAAkB,IAC5F1L,EAAWN,EAAWwE,SACtBlC,EAAStC,EAAWsE,OACpB5C,EAAO1B,EAAWqE,MAIdzE,GAEFI,EAAagL,UAAUjL,GACnBgM,eAAgBnM,EAAQmM,eAAgBD,cAAelM,EAAQkM,cAAeE,kBAAkB,IACpG1L,EAAWN,EAAWwE,SACtBlC,EAAStC,EAAWsE,OACpB5C,EAAO1B,EAAWqE,OAIlB/D,EAAWP,EACXuC,EAASZ,EAAO,KAKtBzB,EAAO8J,MAAM7I,KAAKnB,GAClBE,EAAOyJ,UAAUxI,KAAKZ,GACtBL,EAAO0J,SAASzI,KAAKoB,GACrBrC,EAAO4J,OAAO3I,KAAKQ,GAGrB,MAAOzB,GAST,QAASsL,SAAS5L,GAChB,GAAIE,IACF2L,SACAS,QAAS,KAGX,IAAItM,GAAQA,EAAKa,OAAS,EAAG,CAC3B,GAAId,GAAUC,EAAKA,EAAKa,OAAS,EACR,iBAAdd,IAA0BA,YAAmBD,WAAYC,YAAmBsB,KAAID,IAEzFlB,EAAO2L,MAAQhC,MAAM7E,UAAUxD,MAAMZ,KAAKZ,IAI1CE,EAAOoM,QAAUvM,EACjBG,EAAO2L,MAAQhC,MAAM7E,UAAUxD,MAAMZ,KAAKZ,EAAM,EAAGA,EAAKa,OAAS,IAIrE,MAAOX,GAST,QAASyL,wBAAwB3L,GAC/B,GAAIE,GAAYF,EAAE,EAClB,OAAqB,MAAdE,GAAmC,OAAdA,EAS9B,QAASwL,sBAAsB1L,GAC7B,GAAIE,GAAWF,EAAEsC,QAAQ,EACzB,OAAoB,MAAbpC,GAAiC,OAAbA,EA/U7B,GAAI+I,MAAO3J,OAAOD,SAChBsK,OACE,QAAS,OAAQ,UAAW,YAAa,QAAS,aAAc,MAAO,YACvE,OAAQ,WAAY,UAAW,OAAQ,OAAQ,WAAY,OAAQ,OAAQ,WAC3E,OAAQ,MAAO,OAAQ,OAAQ,MAAO,SAAU,QAAS,QAE3DgB,iBAAkB,MAClBlI,SAAUA,SACViB,SAAUA,SACVoF,OAAQA,OACRD,kBAAmBA,kBACnBK,SAAUA,SACVkC,SAAUA,SACVN,KAAMA,KACN3B,QAASA,QACTkC,UAAWA,UACXvB,UAAWA,UACX8B,QAASA,QACTD,uBAAwBA,uBACxBD,qBAAsBA,sBAGpB5L,SAAWS,QAAQ,eACnBc,IAAMd,QAAQ,cACdiJ,YAAcjJ,QAAQ,eACtB2L,gBAAkB,wJChBtB,QAASK,oBACL,KAAM,IAAI9L,OAAM,mCAEpB,QAAS+L,uBACL,KAAM,IAAI/L,OAAM,qCAsBpB,QAASgM,YAAW1M,GAChB,GAAI2M,mBAAqBC,WAErB,MAAOA,YAAW5M,EAAK,EAG3B,KAAK2M,mBAAqBH,mBAAqBG,mBAAqBC,WAEhE,MADAD,kBAAmBC,WACZA,WAAW5M,EAAK,EAE3B,KAEI,MAAO2M,kBAAiB3M,EAAK,GAC/B,MAAMC,GACJ,IAEI,MAAO0M,kBAAiB9L,KAAK,KAAMb,EAAK,GAC1C,MAAMC,GAEJ,MAAO0M,kBAAiB9L,KAAKf,KAAME,EAAK,KAMpD,QAAS6M,iBAAgB7M,GACrB,GAAI8M,qBAAuBC,aAEvB,MAAOA,cAAa/M,EAGxB,KAAK8M,qBAAuBL,sBAAwBK,qBAAuBC,aAEvE,MADAD,oBAAqBC,aACdA,aAAa/M,EAExB,KAEI,MAAO8M,oBAAmB9M,GAC5B,MAAOC,GACL,IAEI,MAAO6M,oBAAmBjM,KAAK,KAAMb,GACvC,MAAOC,GAGL,MAAO6M,oBAAmBjM,KAAKf,KAAME,KAYjD,QAASgN,mBACAC,UAAaC,eAGlBD,UAAW,EACPC,aAAapM,OACbqM,MAAQD,aAAa9J,OAAO+J,OAE5BC,YAAc,EAEdD,MAAMrM,QACNuM,cAIR,QAASA,cACL,IAAIJ,SAAJ,CAGA,GAAIjN,GAAU0M,WAAWM,gBACzBC,WAAW,CAGX,KADA,GAAIhN,GAAMkN,MAAMrM,OACVb,GAAK,CAGP,IAFAiN,aAAeC,MACfA,WACSC,WAAanN,GACdiN,cACAA,aAAaE,YAAYE,KAGjCF,aAAc,EACdnN,EAAMkN,MAAMrM,OAEhBoM,aAAe,KACfD,UAAW,EACXJ,gBAAgB7M,IAiBpB,QAASuN,MAAKvN,EAAKC,GACfH,KAAK0N,IAAMxN,EACXF,KAAK2N,MAAQxN,EAYjB,QAASyN,SAhKT,GAAIzL,SAAU1C,OAAOD,WAOjBqN,iBACAG,oBAQH,WACG,IAEQH,iBADsB,kBAAfC,YACYA,WAEAJ,iBAEzB,MAAOxM,GACL2M,iBAAmBH,iBAEvB,IAEQM,mBADwB,kBAAjBC,cACcA,aAEAN,oBAE3B,MAAOzM,GACL8M,mBAAqBL,uBAuD7B,IAAIU,UACAF,UAAW,EACXC,aACAE,YAAc,CAyClBnL,SAAQ0L,SAAW,SAAU3N,GACzB,GAAIC,GAAO,GAAI6J,OAAMzH,UAAUvB,OAAS,EACxC,IAAIuB,UAAUvB,OAAS,EACnB,IAAK,GAAIX,GAAI,EAAGA,EAAIkC,UAAUvB,OAAQX,IAClCF,EAAKE,EAAI,GAAKkC,UAAUlC,EAGhCgN,OAAM3L,KAAK,GAAI+L,MAAKvN,EAAKC,IACJ,IAAjBkN,MAAMrM,QAAiBmM,UACvBP,WAAWW,aASnBE,KAAKtI,UAAUqI,IAAM,WACjBxN,KAAK0N,IAAIhE,MAAM,KAAM1J,KAAK2N,QAE9BxL,QAAQ2L,MAAQ,UAChB3L,QAAQqI,SAAU,EAClBrI,QAAQK,OACRL,QAAQ4L,QACR5L,QAAQ6L,QAAU,GAClB7L,QAAQ8L,YAIR9L,QAAQ+L,GAAKN,KACbzL,QAAQgM,YAAcP,KACtBzL,QAAQiM,KAAOR,KACfzL,QAAQkM,IAAMT,KACdzL,QAAQmM,eAAiBV,KACzBzL,QAAQoM,mBAAqBX,KAC7BzL,QAAQqM,KAAOZ,KACfzL,QAAQsM,gBAAkBb,KAC1BzL,QAAQuM,oBAAsBd,KAE9BzL,QAAQwM,UAAY,SAAUzO,GAAQ,UAEtCiC,QAAQyM,QAAU,SAAU1O,GACxB,KAAM,IAAIU,OAAM,qCAGpBuB,QAAQQ,IAAM,WAAc,MAAO,KACnCR,QAAQ0M,MAAQ,SAAU3O,GACtB,KAAM,IAAIU,OAAM,mCAEpBuB,QAAQ2M,MAAQ,WAAa,MAAO;CCtLlC,SAAS5O,GAgEV,QAASK,GAAML,GACd,KAAM,IAAI6O,YAAW3G,EAAOlI,IAW7B,QAASE,GAAIF,EAAOK,GAGnB,IAFA,GAAIH,GAASF,EAAMc,OACfb,KACGC,KACND,EAAOC,GAAUG,EAAGL,EAAME,GAE3B,OAAOD,GAaR,QAASA,GAAUD,EAAQK,GAC1B,GAAIJ,GAAQD,EAAO6C,MAAM,KACrB1C,EAAS,EAWb,OAVIF,GAAMa,OAAS,IAGlBX,EAASF,EAAM,GAAK,IACpBD,EAASC,EAAM,IAGhBD,EAASA,EAAO+B,QAAQuF,EAAiB,KAGlCnH,EADOD,EADDF,EAAO6C,MAAM,KACAxC,GAAIyC,KAAK,KAiBpC,QAAS3C,GAAWH,GAMnB,IALA,GAGIK,GACAH,EAJAD,KACAE,EAAU,EACVG,EAASN,EAAOc,OAGbX,EAAUG,GAChBD,EAAQL,EAAO2H,WAAWxH,KACtBE,GAAS,OAAUA,GAAS,OAAUF,EAAUG,GAEnDJ,EAAQF,EAAO2H,WAAWxH,KACF,QAAX,MAARD,GACJD,EAAOuB,OAAe,KAARnB,IAAkB,KAAe,KAARH,GAAiB,QAIxDD,EAAOuB,KAAKnB,GACZF,MAGDF,EAAOuB,KAAKnB,EAGd,OAAOJ,GAWR,QAASK,GAAWN,GACnB,MAAOE,GAAIF,EAAO,SAASA,GAC1B,GAAIK,GAAS,EAOb,OANIL,GAAQ,QACXA,GAAS,MACTK,GAAU4H,EAAmBjI,IAAU,GAAK,KAAQ,OACpDA,EAAQ,MAAiB,KAARA,GAElBK,GAAU4H,EAAmBjI,KAE3B8C,KAAK,IAYT,QAASrC,GAAaT,GACrB,MAAIA,GAAY,GAAK,GACbA,EAAY,GAEhBA,EAAY,GAAK,GACbA,EAAY,GAEhBA,EAAY,GAAK,GACbA,EAAY,GAEbsF,EAcR,QAASjG,GAAaW,EAAOK,GAG5B,MAAOL,GAAQ,GAAK,IAAMA,EAAQ,MAAgB,GAARK,IAAc,GAQzD,QAAS8B,GAAMnC,EAAOK,EAAWH,GAChC,GAAID,GAAI,CAGR,KAFAD,EAAQE,EAAY4O,EAAM9O,EAAQyG,GAAQzG,GAAS,EACnDA,GAAS8O,EAAM9O,EAAQK,GACOL,EAAQ0H,EAAgBb,GAAQ,EAAG5G,GAAKqF,EACrEtF,EAAQ8O,EAAM9O,EAAQ0H,EAEvB,OAAOoH,GAAM7O,GAAKyH,EAAgB,GAAK1H,GAASA,EAAQmF,IAUzD,QAASvE,GAAOZ,GAEf,GAEIE,GAIAD,EACAE,EACAd,EACAuB,EACAR,EACAsF,EACA1D,EACAzB,EAEAqC,EAfAwC,KACA1F,EAAcM,EAAMc,OAEpB8F,EAAI,EACJzB,EAAI2B,EACJL,EAAOE,CAqBX,KALA1G,EAAQD,EAAMiH,YAAYa,GACtB7H,EAAQ,IACXA,EAAQ,GAGJE,EAAI,EAAGA,EAAIF,IAASE,EAEpBH,EAAM2H,WAAWxH,IAAM,KAC1BE,EAAM,aAEP+E,EAAO5D,KAAKxB,EAAM2H,WAAWxH,GAM9B,KAAKd,EAAQY,EAAQ,EAAIA,EAAQ,EAAI,EAAGZ,EAAQK,GAAwC,CAOvF,IAAKkB,EAAOgG,EAAGxG,EAAI,EAAGsF,EAAIJ,EAErBjG,GAASK,GACZW,EAAM,iBAGP2B,EAAQvB,EAAaT,EAAM2H,WAAWtI,OAElC2C,GAASsD,GAAQtD,EAAQ8M,GAAOzI,EAASO,GAAKxG,KACjDC,EAAM,YAGPuG,GAAK5E,EAAQ5B,EACbG,EAAImF,GAAKe,EAAOpB,EAAQK,GAAKe,EAAOI,EAAOA,EAAOnB,EAAIe,IAElDzE,EAAQzB,GAfuCmF,GAAKJ,EAmBxD1C,EAAa0C,EAAO/E,EAChBH,EAAI0O,EAAMzI,EAASzD,IACtBvC,EAAM,YAGPD,GAAKwC,CAIN1C,GAAMkF,EAAOtE,OAAS,EACtB2F,EAAOtE,EAAMyE,EAAIhG,EAAMV,EAAa,GAARU,GAIxBkO,EAAMlI,EAAI1G,GAAOmG,EAASlB,GAC7B9E,EAAM,YAGP8E,GAAK2J,EAAMlI,EAAI1G,GACf0G,GAAK1G,EAGLkF,EAAO4D,OAAOpC,IAAK,EAAGzB,GAIvB,MAAO7E,GAAW8E,GAUnB,QAAShF,GAAOJ,GACf,GAAIE,GACAD,EACAK,EACAG,EACAG,EACAR,EACAsF,EACA1D,EACAzB,EACAqC,EACAwC,EAGA1F,EAEAkH,EACAzB,EACAsB,EANA8B,IAoBJ,KAXAvI,EAAQG,EAAWH,GAGnBN,EAAcM,EAAMc,OAGpBZ,EAAI4G,EACJ7G,EAAQ,EACRW,EAAO+F,EAGFvG,EAAI,EAAGA,EAAIV,IAAeU,GAC9BgF,EAAepF,EAAMI,IACF,KAClBmI,EAAO/G,KAAKyG,EAAmB7C,GAejC,KAXA9E,EAAiBG,EAAc8H,EAAOzH,OAMlCL,GACH8H,EAAO/G,KAAKsG,GAINxH,EAAiBZ,GAAa,CAIpC,IAAKgG,EAAIW,EAAQjG,EAAI,EAAGA,EAAIV,IAAeU,GAC1CgF,EAAepF,EAAMI,KACDF,GAAKkF,EAAeM,IACvCA,EAAIN,EAcN,KARAwB,EAAwBtG,EAAiB,EACrCoF,EAAIxF,EAAI4O,GAAOzI,EAASpG,GAAS2G,IACpCvG,EAAM,YAGPJ,IAAUyF,EAAIxF,GAAK0G,EACnB1G,EAAIwF,EAECtF,EAAI,EAAGA,EAAIV,IAAeU,EAO9B,GANAgF,EAAepF,EAAMI,GAEjBgF,EAAelF,KAAOD,EAAQoG,GACjChG,EAAM,YAGH+E,GAAgBlF,EAAG,CAEtB,IAAK8B,EAAI/B,EAAOM,EAAI+E,EACnB1C,EAAIrC,GAAKK,EAAOyE,EAAQ9E,GAAKK,EAAOiG,EAAOA,EAAOtG,EAAIK,IAClDoB,EAAIY,GAFqCrC,GAAK+E,EAKlDmB,EAAUzE,EAAIY,EACduC,EAAaG,EAAO1C,EACpB2F,EAAO/G,KACNyG,EAAmB5I,EAAauD,EAAI6D,EAAUtB,EAAY,KAE3DnD,EAAI8M,EAAMrI,EAAUtB,EAGrBoD,GAAO/G,KAAKyG,EAAmB5I,EAAa2C,EAAG,KAC/CpB,EAAOuB,EAAMlC,EAAO2G,EAAuBtG,GAAkBG,GAC7DR,EAAQ,IACNK,IAIFL,IACAC,EAGH,MAAOqI,GAAOzF,KAAK,IAcpB,QAAS4C,GAAU1F,GAClB,MAAOC,GAAUD,EAAO,SAASA,GAChC,MAAOuI,GAAcvF,KAAKhD,GACvBY,EAAOZ,EAAOyB,MAAM,GAAGe,eACvBxC,IAeL,QAASgC,GAAQhC,GAChB,MAAOC,GAAUD,EAAO,SAASA,GAChC,MAAOwG,GAAcxD,KAAKhD,GACvB,OAASI,EAAOJ,GAChBA,IAvdL,GAAIO,GAAgC,gBAAXjB,UAAuBA,UAC9CA,QAAQyP,UAAYzP,QAClBsD,EAA8B,gBAAVrD,SAAsBA,SAC5CA,OAAOwP,UAAYxP,OACjB6F,EAA8B,gBAAVxF,SAAsBA,MAE7CwF,GAAWxF,SAAWwF,GACtBA,EAAWzF,SAAWyF,GACtBA,EAAWvF,OAASuF,IAEpBpF,EAAOoF,EAQR,IAAI1F,GAiCJkH,EA9BAP,EAAS,WAGTf,EAAO,GACPD,EAAO,EACPwB,EAAO,GACP1B,EAAO,GACPsB,EAAO,IACPE,EAAc,GACdG,EAAW,IACXgB,EAAY,IAGZS,EAAgB,QAChB/B,EAAgB,eAChBc,EAAkB,4BAGlBY,GACC8G,SAAY,kDACZC,YAAa,iDACbC,gBAAiB,iBAIlBxH,EAAgBpC,EAAOD,EACvByJ,EAAQ5L,KAAKiM,MACblH,EAAqBmH,OAAOC,YAyc5B,IA3BA3P,GAMCoO,QAAW,QAQXwB,MACCC,OAAUpP,EACVqP,OAAUlP,GAEXiP,OAAU3O,EACV4O,OAAUpP,EACV4H,QAAWhG,EACXyN,UAAa/J,GAOI,kBAAVlG,SACc,gBAAdA,QAAOC,KACdD,OAAOC,IAEPD,OAAO,WAAY,WAClB,MAAOE,SAEF,IAAIa,GAAeqC,EACzB,GAAIrD,OAAOD,SAAWiB,EAErBqC,EAAWtD,QAAUI,MAGrB,KAAKkH,IAAOlH,GACXA,EAASgQ,eAAe9I,KAASrG,EAAYqG,GAAOlH,EAASkH,QAK/D5G,GAAK2P,SAAWjQ,GAGhBI,qKC/fF,YAKA,SAAS4P,gBAAevP,EAAKH,GAC3B,MAAO0I,QAAOzD,UAAUyK,eAAe7O,KAAKV,EAAKH,GAGnDT,OAAOD,QAAU,SAASa,EAAIH,EAAKC,EAAIC,GACrCF,EAAMA,GAAO,IACbC,EAAKA,GAAM,GACX,IAAII,KAEJ,IAAkB,gBAAPF,IAAiC,IAAdA,EAAGW,OAC/B,MAAOT,EAGT,IAAIE,GAAS,KACbJ,GAAKA,EAAG0C,MAAM7C,EAEd,IAAII,GAAU,GACVF,IAAsC,gBAApBA,GAAQ0P,UAC5BxP,EAAUF,EAAQ0P,QAGpB,IAAI5N,GAAM7B,EAAGW,MAETV,GAAU,GAAK4B,EAAM5B,IACvB4B,EAAM5B,EAGR,KAAK,GAAIiF,GAAI,EAAGA,EAAIrD,IAAOqD,EAAG,CAC5B,GAEI/E,GAAM6B,EAAM1B,EAAGG,EAFfvB,EAAIc,EAAGkF,GAAGtD,QAAQxB,EAAQ,OAC1B6E,EAAM/F,EAAEiH,QAAQrG,EAGhBmF,IAAO,GACT9E,EAAOjB,EAAEkD,OAAO,EAAG6C,GACnBjD,EAAO9C,EAAEkD,OAAO6C,EAAM,KAEtB9E,EAAOjB,EACP8C,EAAO,IAGT1B,EAAIyG,mBAAmB5G,GACvBM,EAAIsG,mBAAmB/E,GAElBuN,eAAerP,EAAKI,GAEdoP,QAAQxP,EAAII,IACrBJ,EAAII,GAAGe,KAAKZ,GAEZP,EAAII,IAAMJ,EAAII,GAAIG,GAJlBP,EAAII,GAAKG,EAQb,MAAOP,GAGT,IAAIwP,SAAU/F,MAAM+F,SAAW,SAAU1P,GACvC,MAA8C,mBAAvCuI,OAAOzD,UAAUkE,SAAStI,KAAKV,8CC7DxC,YAgDA,SAAS2P,KAAK3P,EAAIH,GAChB,GAAIG,EAAG2P,IAAK,MAAO3P,GAAG2P,IAAI9P,EAE1B,KAAK,GADDC,MACKC,EAAI,EAAGA,EAAIC,EAAGW,OAAQZ,IAC7BD,EAAIuB,KAAKxB,EAAEG,EAAGD,GAAIA,GAEpB,OAAOD,GApDT,GAAI8P,oBAAqB,SAAS5P,GAChC,aAAeA,IACb,IAAK,SACH,MAAOA,EAET,KAAK,UACH,MAAOA,GAAI,OAAS,OAEtB,KAAK,SACH,MAAO6P,UAAS7P,GAAKA,EAAI,EAE3B,SACE,MAAO,IAIbZ,QAAOD,QAAU,SAASa,EAAKH,EAAKC,EAAIC,GAOtC,MANAF,GAAMA,GAAO,IACbC,EAAKA,GAAM,IACC,OAARE,IACFA,MAAM,IAGW,gBAARA,GACF2P,IAAIG,WAAW9P,GAAM,SAASD,GACnC,GAAIO,GAAK4H,mBAAmB0H,mBAAmB7P,IAAMD,CACrD,OAAI4P,SAAQ1P,EAAID,IACP4P,IAAI3P,EAAID,GAAI,SAASC,GAC1B,MAAOM,GAAK4H,mBAAmB0H,mBAAmB5P,MACjD2C,KAAK9C,GAEDS,EAAK4H,mBAAmB0H,mBAAmB5P,EAAID,OAEvD4C,KAAK9C,GAILE,EACEmI,mBAAmB0H,mBAAmB7P,IAASD,EAC/CoI,mBAAmB0H,mBAAmB5P,IAF3B,GAKpB,IAAI0P,SAAU/F,MAAM+F,SAAW,SAAU1P,GACvC,MAA8C,mBAAvCuI,OAAOzD,UAAUkE,SAAStI,KAAKV,IAYpC8P,WAAavH,OAAOC,MAAQ,SAAUxI,GACxC,GAAIH,KACJ,KAAK,GAAIC,KAAOE,GACVuI,OAAOzD,UAAUyK,eAAe7O,KAAKV,EAAKF,IAAMD,EAAIwB,KAAKvB,EAE/D,OAAOD,8CCnFT,YAEAV,SAAQiQ,OAASjQ,QAAQ0E,MAAQxD,QAAQ,YACzClB,QAAQkQ,OAASlQ,QAAQsJ,UAAYpI,QAAQ",
  "file": "omnipath.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nmodule.exports = require('./omni-path');\nmodule.exports.Posix = module.exports.posix = require('./omni-posix');\nmodule.exports.Windows = module.exports.windows = module.exports.win32 = require('./omni-windows');\nmodule.exports.Url = module.exports.url = require('./omni-url');\n",
    "/* istanbul ignore next - Don't include native NodeJS code in code-coverage */\n(function () {\n  'use strict';\n\n  var path = require('path');\n\n  if (path.posix && path.windows) {\n    // We're running in Node v0.12+, so use the built-in \"path\" module\n    module.exports = path;\n    return;\n  }\n\n  // On older versions of Node and Browserify, use the following code instead of the built-in \"path\" module.\n  // This code is direct copy of the \"path\" module from Node v0.12\n  // https://github.com/joyent/node/blob/master/lib/path.js\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n  var isWindows = process.platform === 'win32';\n  var util = require('../util');\n\n\n  // resolves . and .. elements in a path array with directory names there\n  // must be no slashes or device names (c:\\) in the array\n  // (so also no leading and trailing slashes - it does not distinguish\n  // relative and absolute paths)\n  function normalizeArray (parts, allowAboveRoot) {\n    var res = [];\n    for (var i = 0; i < parts.length; i++) {\n      var p = parts[i];\n\n      // ignore empty parts\n      if (!p || p === '.') { continue; }\n\n      if (p === '..') {\n        if (res.length && res[res.length - 1] !== '..') {\n          res.pop();\n        }\n        else if (allowAboveRoot) {\n          res.push('..');\n        }\n      }\n      else {\n        res.push(p);\n      }\n    }\n\n    return res;\n  }\n\n  // returns an array with empty elements removed from either end of the input\n  // array or the original array if no elements need to be removed\n  function trimArray (arr) {\n    var lastIndex = arr.length - 1;\n    var start = 0;\n    for (; start <= lastIndex; start++) {\n      if (arr[start]) { break; }\n    }\n\n    var end = lastIndex;\n    for (; end >= 0; end--) {\n      if (arr[end]) { break; }\n    }\n\n    if (start === 0 && end === lastIndex) { return arr; }\n    if (start > end) { return []; }\n    return arr.slice(start, end + 1);\n  }\n\n  // Regex to split a windows path into three parts: [*, device, slash,\n  // tail] windows-only\n  var splitDeviceRe =\n      /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\n  // Regex to split the tail part of the above into [*, dir, basename, ext]\n  var splitTailRe =\n      /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\n\n  var win32 = {};\n\n  // Function to split a filename into [root, dir, basename, ext]\n  function win32SplitPath (filename) {\n    // Separate device+slash from tail\n    var result = splitDeviceRe.exec(filename),\n        device = (result[1] || '') + (result[2] || ''),\n        tail = result[3] || '';\n    // Split the tail into dir, basename and extension\n    var result2 = splitTailRe.exec(tail),\n        dir = result2[1],\n        basename = result2[2],\n        ext = result2[3];\n    return [device, dir, basename, ext];\n  }\n\n  function win32StatPath (path) {\n    var result = splitDeviceRe.exec(path),\n        device = result[1] || '',\n        isUnc = !!device && device[1] !== ':';\n    return {\n      device: device,\n      isUnc: isUnc,\n      isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\n      tail: result[3]\n    };\n  }\n\n  function normalizeUNCRoot (device) {\n    return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\n  }\n\n  // path.resolve([from ...], to)\n  win32.resolve = function () {\n    var resolvedDevice = '',\n        resolvedTail = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path;\n      if (i >= 0) {\n        path = arguments[i];\n      }\n      else if (!resolvedDevice) {\n        path = process.cwd();\n      }\n      else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive. We're sure the device is not\n        // an unc path at this points, because unc paths are always absolute.\n        path = process.env['=' + resolvedDevice];\n        // Verify that a drive-local cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (!path || path.substr(0, 3).toLowerCase() !==\n            resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      // Skip empty and invalid entries\n      if (!util.isString(path)) {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      }\n      else if (!path) {\n        continue;\n      }\n\n      var result = win32StatPath(path),\n          device = result.device,\n          isUnc = result.isUnc,\n          isAbsolute = result.isAbsolute,\n          tail = result.tail;\n\n      if (device &&\n          resolvedDevice &&\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (!resolvedDevice) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = tail + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice && resolvedAbsolute) {\n        break;\n      }\n    }\n\n    // Convert slashes to backslashes when `resolvedDevice` points to an UNC\n    // root. Also squash multiple slashes into a single one where appropriate.\n    if (isUnc) {\n      resolvedDevice = normalizeUNCRoot(resolvedDevice);\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\n      !resolvedAbsolute).join('\\\\');\n\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n           '.';\n  };\n\n\n  win32.normalize = function (path) {\n    var result = win32StatPath(path),\n        device = result.device,\n        isUnc = result.isUnc,\n        isAbsolute = result.isAbsolute,\n        tail = result.tail,\n        trailingSlash = /[\\\\\\/]$/.test(tail);\n\n    // Normalize the tail path\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\n\n    if (!tail && !isAbsolute) {\n      tail = '.';\n    }\n    if (tail && trailingSlash) {\n      tail += '\\\\';\n    }\n\n    // Convert slashes to backslashes when `device` points to an UNC root.\n    // Also squash multiple slashes into a single one where appropriate.\n    if (isUnc) {\n      device = normalizeUNCRoot(device);\n    }\n\n    return device + (isAbsolute ? '\\\\' : '') + tail;\n  };\n\n\n  win32.isAbsolute = function (path) {\n    return win32StatPath(path).isAbsolute;\n  };\n\n  win32.join = function () {\n    var paths = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i];\n      if (!util.isString(arg)) {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      if (arg) {\n        paths.push(arg);\n      }\n    }\n\n    var joined = paths.join('\\\\');\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n    if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n      joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\n    }\n\n    return win32.normalize(joined);\n  };\n\n\n  // path.relative(from, to)\n  // it will solve the relative path from 'from' to 'to', for instance:\n  // from = 'C:\\\\orandea\\\\test\\\\aaa'\n  // to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  win32.relative = function (from, to) {\n    from = win32.resolve(from);\n    to = win32.resolve(to);\n\n    // windows is not case sensitive\n    var lowerFrom = from.toLowerCase();\n    var lowerTo = to.toLowerCase();\n\n    var toParts = trimArray(to.split('\\\\'));\n\n    var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\n    var lowerToParts = trimArray(lowerTo.split('\\\\'));\n\n    var length = Math.min(lowerFromParts.length, lowerToParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (lowerFromParts[i] !== lowerToParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n\n    if (samePartsLength == 0) {\n      return to;\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < lowerFromParts.length; i++) {\n      outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('\\\\');\n  };\n\n\n  win32._makeLong = function (path) {\n    // Note: this will *probably* throw somewhere.\n    if (!util.isString(path)) { return path; }\n\n    if (!path) {\n      return '';\n    }\n\n    var resolvedPath = win32.resolve(path);\n\n    if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n      // path is local filesystem path, which needs to be converted\n      // to long UNC path.\n      return '\\\\\\\\?\\\\' + resolvedPath;\n    }\n    else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n      // path is network UNC path, which needs to be converted\n      // to long UNC path.\n      return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n    }\n\n    return path;\n  };\n\n\n  win32.dirname = function (path) {\n    var result = win32SplitPath(path),\n        root = result[0],\n        dir = result[1];\n\n    if (!root && !dir) {\n      // No dirname whatsoever\n      return '.';\n    }\n\n    if (dir) {\n      // It has a dirname, strip trailing slash\n      dir = dir.substr(0, dir.length - 1);\n    }\n\n    return root + dir;\n  };\n\n\n  win32.basename = function (path, ext) {\n    var f = win32SplitPath(path)[2];\n    // TODO: make this comparison case-insensitive on windows?\n    if (ext && f.substr(-1 * ext.length) === ext) {\n      f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n  };\n\n\n  win32.extname = function (path) {\n    return win32SplitPath(path)[3];\n  };\n\n\n  win32.format = function (pathObject) {\n    if (!util.isObject(pathObject)) {\n      throw new TypeError(\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n      );\n    }\n\n    var root = pathObject.root || '';\n\n    if (!util.isString(root)) {\n      throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n          typeof pathObject.root\n      );\n    }\n\n    var dir = pathObject.dir;\n    var base = pathObject.base || '';\n    if (!dir) {\n      return base;\n    }\n    if (dir[dir.length - 1] === win32.sep) {\n      return dir + base;\n    }\n    return dir + win32.sep + base;\n  };\n\n\n  win32.parse = function (pathString) {\n    if (!util.isString(pathString)) {\n      throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n      );\n    }\n    var allParts = win32SplitPath(pathString);\n    if (!allParts || allParts.length !== 4) {\n      throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n    }\n    return {\n      root: allParts[0],\n      dir: allParts[0] + allParts[1].slice(0, -1),\n      base: allParts[2],\n      ext: allParts[3],\n      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n    };\n  };\n\n\n  win32.sep = '\\\\';\n  win32.delimiter = ';';\n\n\n  // Split a filename into [root, dir, basename, ext], unix version\n  // 'root' is just a slash, or nothing.\n  var splitPathRe =\n      /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  var posix = {};\n\n\n  function posixSplitPath (filename) {\n    return splitPathRe.exec(filename).slice(1);\n  }\n\n\n  // path.resolve([from ...], to)\n  // posix version\n  posix.resolve = function () {\n    var resolvedPath = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = (i >= 0) ? arguments[i] : process.cwd();\n\n      // Skip empty and invalid entries\n      if (!util.isString(path)) {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      }\n      else if (!path) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path[0] === '/';\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeArray(resolvedPath.split('/'),\n      !resolvedAbsolute).join('/');\n\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n  };\n\n  // path.normalize(path)\n  // posix version\n  posix.normalize = function (path) {\n    var isAbsolute = posix.isAbsolute(path),\n        trailingSlash = path && path[path.length - 1] === '/';\n\n    // Normalize the path\n    path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n    if (!path && !isAbsolute) {\n      path = '.';\n    }\n    if (path && trailingSlash) {\n      path += '/';\n    }\n\n    return (isAbsolute ? '/' : '') + path;\n  };\n\n  // posix version\n  posix.isAbsolute = function (path) {\n    return path.charAt(0) === '/';\n  };\n\n  // posix version\n  posix.join = function () {\n    var path = '';\n    for (var i = 0; i < arguments.length; i++) {\n      var segment = arguments[i];\n      if (!util.isString(segment)) {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      if (segment) {\n        if (!path) {\n          path += segment;\n        }\n        else {\n          path += '/' + segment;\n        }\n      }\n    }\n    return posix.normalize(path);\n  };\n\n\n  // path.relative(from, to)\n  // posix version\n  posix.relative = function (from, to) {\n    from = posix.resolve(from).substr(1);\n    to = posix.resolve(to).substr(1);\n\n    var fromParts = trimArray(from.split('/'));\n    var toParts = trimArray(to.split('/'));\n\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n      outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('/');\n  };\n\n\n  posix._makeLong = function (path) {\n    return path;\n  };\n\n\n  posix.dirname = function (path) {\n    var result = posixSplitPath(path),\n        root = result[0],\n        dir = result[1];\n\n    if (!root && !dir) {\n      // No dirname whatsoever\n      return '.';\n    }\n\n    if (dir) {\n      // It has a dirname, strip trailing slash\n      dir = dir.substr(0, dir.length - 1);\n    }\n\n    return root + dir;\n  };\n\n\n  posix.basename = function (path, ext) {\n    var f = posixSplitPath(path)[2];\n    // TODO: make this comparison case-insensitive on windows?\n    if (ext && f.substr(-1 * ext.length) === ext) {\n      f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n  };\n\n\n  posix.extname = function (path) {\n    return posixSplitPath(path)[3];\n  };\n\n\n  posix.format = function (pathObject) {\n    if (!util.isObject(pathObject)) {\n      throw new TypeError(\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n      );\n    }\n\n    var root = pathObject.root || '';\n\n    if (!util.isString(root)) {\n      throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n          typeof pathObject.root\n      );\n    }\n\n    var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\n    var base = pathObject.base || '';\n    return dir + base;\n  };\n\n\n  posix.parse = function (pathString) {\n    if (!util.isString(pathString)) {\n      throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n      );\n    }\n    var allParts = posixSplitPath(pathString);\n    if (!allParts || allParts.length !== 4) {\n      throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n    }\n    allParts[1] = allParts[1] || '';\n    allParts[2] = allParts[2] || '';\n    allParts[3] = allParts[3] || '';\n\n    return {\n      root: allParts[0],\n      dir: allParts[0] + allParts[1].slice(0, -1),\n      base: allParts[2],\n      ext: allParts[3],\n      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n    };\n  };\n\n\n  posix.sep = '/';\n  posix.delimiter = ':';\n\n\n  if (isWindows) { module.exports = win32; }\n  else /* posix */\n  { module.exports = posix; }\n\n  module.exports.posix = posix;\n  module.exports.win32 = win32;\n\n}());\n",
    "/* istanbul ignore next - Don't include native NodeJS code in code-coverage */\n(function () {\n  'use strict';\n\n  var path = require('path');\n\n  if (path.posix && path.windows) {\n    // We're running in Node v0.12+, so use the built-in \"url\" module\n    module.exports = require('url');\n    return;\n  }\n\n  // On older versions of Node and Browserify, use the following code instead of the built-in \"url\" module.\n  // This code is direct copy of the \"url\" module from Node v0.12\n  // https://github.com/joyent/node/blob/master/lib/url.js\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  var punycode = require('punycode');\n  var util = require('../util');\n\n  exports.parse = urlParse;\n  exports.resolve = urlResolve;\n  exports.resolveObject = urlResolveObject;\n  exports.format = urlFormat;\n\n  exports.Url = Url;\n\n  function Url () {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n  }\n\n  // Reference: RFC 3986, RFC 1808, RFC 2396\n\n  // define these here so at least they only have to be\n  // compiled once on the first module load.\n  var protocolPattern = /^([a-z0-9.+-]+:)/i,\n      portPattern = /:[0-9]*$/,\n\n      // Special case for a simple path URL\n      simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n      // RFC 2396: characters reserved for delimiting URLs.\n      // We actually just auto-escape these.\n      delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n      // RFC 2396: characters not allowed for various reasons.\n      unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n      autoEscape = ['\\''].concat(unwise),\n      // Characters that are never ever allowed in a hostname.\n      // Note that any invalid chars are also handled, but these\n      // are the ones that are *expected* to be seen, so we fast-path\n      // them.\n      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n      hostEndingChars = ['/', '?', '#'],\n      hostnameMaxLen = 255,\n      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n      // protocols that can allow \"unsafe\" and \"unwise\" chars.\n      unsafeProtocol = {\n        javascript: true,\n        'javascript:': true\n      },\n      // protocols that never have a hostname.\n      hostlessProtocol = {\n        javascript: true,\n        'javascript:': true\n      },\n      // protocols that always contain a // bit.\n      slashedProtocol = {\n        http: true,\n        https: true,\n        ftp: true,\n        gopher: true,\n        file: true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true\n      },\n      querystring = require('querystring');\n\n  function urlParse (url, parseQueryString, slashesDenoteHost) {\n    if (url && util.isObject(url) && url instanceof Url) { return url; }\n\n    var u = new Url();\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n  }\n\n  Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n    if (!util.isString(url)) {\n      throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    var queryIndex = url.indexOf('?'),\n        splitter =\n            (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n        uSplit = url.split(splitter),\n        slashRegex = /\\\\/g;\n    uSplit[0] = uSplit[0].replace(slashRegex, '/');\n    url = uSplit.join(splitter);\n\n    var rest = url;\n\n    // trim before proceeding.\n    // This is to support parse stuff like \"  http://foo.com  \\n\"\n    rest = rest.trim();\n\n    if (!slashesDenoteHost && url.split('#').length === 1) {\n      // Try fast path regexp\n      var simplePath = simplePathPattern.exec(rest);\n      if (simplePath) {\n        this.path = rest;\n        this.href = rest;\n        this.pathname = simplePath[1];\n        if (simplePath[2]) {\n          this.search = simplePath[2];\n          if (parseQueryString) {\n            this.query = querystring.parse(this.search.substr(1));\n          }\n          else {\n            this.query = this.search.substr(1);\n          }\n        }\n        else if (parseQueryString) {\n          this.search = '';\n          this.query = {};\n        }\n        return this;\n      }\n    }\n\n    var proto = protocolPattern.exec(rest);\n    if (proto) {\n      proto = proto[0];\n      var lowerProto = proto.toLowerCase();\n      this.protocol = lowerProto;\n      rest = rest.substr(proto.length);\n    }\n\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n    if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n      var slashes = rest.substr(0, 2) === '//';\n      if (slashes && !(proto && hostlessProtocol[proto])) {\n        rest = rest.substr(2);\n        this.slashes = true;\n      }\n    }\n\n    if (!hostlessProtocol[proto] &&\n        (slashes || (proto && !slashedProtocol[proto]))) {\n\n      // there's a hostname.\n      // the first instance of /, ?, ;, or # ends the host.\n      //\n      // If there is an @ in the hostname, then non-host chars *are* allowed\n      // to the left of the last @ sign, unless some host-ending character\n      // comes *before* the @-sign.\n      // URLs are obnoxious.\n      //\n      // ex:\n      // http://a@b@c/ => user:a@b host:c\n      // http://a@b?@c => user:a host:c path:/?@c\n\n      // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n      // Review our test case against browsers more comprehensively.\n\n      // find the first instance of any hostEndingChars\n      var hostEnd = -1;\n      for (var i = 0; i < hostEndingChars.length; i++) {\n        var hec = rest.indexOf(hostEndingChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n      }\n\n      // at this point, either we have an explicit point where the\n      // auth portion cannot go past, or the last @ char is the decider.\n      var auth, atSign;\n      if (hostEnd === -1) {\n        // atSign can be anywhere.\n        atSign = rest.lastIndexOf('@');\n      }\n      else {\n        // atSign must be in auth portion.\n        // http://a@b/c@d => host:b auth:a path:/c@d\n        atSign = rest.lastIndexOf('@', hostEnd);\n      }\n\n      // Now we have a portion which is definitely the auth.\n      // Pull that off.\n      if (atSign !== -1) {\n        auth = rest.slice(0, atSign);\n        rest = rest.slice(atSign + 1);\n        this.auth = decodeURIComponent(auth);\n      }\n\n      // the host is the remaining to the left of the first non-host char\n      hostEnd = -1;\n      for (var i = 0; i < nonHostChars.length; i++) {\n        var hec = rest.indexOf(nonHostChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n      }\n      // if we still have not hit it, then the entire thing is a host.\n      if (hostEnd === -1) { hostEnd = rest.length; }\n\n      this.host = rest.slice(0, hostEnd);\n      rest = rest.slice(hostEnd);\n\n      // pull out port.\n      this.parseHost();\n\n      // we've indicated that there is a hostname,\n      // so even if it's empty, it has to be present.\n      this.hostname = this.hostname || '';\n\n      // if hostname begins with [ and ends with ]\n      // assume that it's an IPv6 address.\n      var ipv6Hostname = this.hostname[0] === '[' &&\n          this.hostname[this.hostname.length - 1] === ']';\n\n      // validate a little.\n      if (!ipv6Hostname) {\n        var hostparts = this.hostname.split(/\\./);\n        for (var i = 0, l = hostparts.length; i < l; i++) {\n          var part = hostparts[i];\n          if (!part) { continue; }\n          if (!part.match(hostnamePartPattern)) {\n            var newpart = '';\n            for (var j = 0, k = part.length; j < k; j++) {\n              if (part.charCodeAt(j) > 127) {\n                // we replace non-ASCII char with a temporary placeholder\n                // we need this to make sure size of hostname is not\n                // broken by replacing non-ASCII by nothing\n                newpart += 'x';\n              }\n              else {\n                newpart += part[j];\n              }\n            }\n            // we test again with ASCII char only\n            if (!newpart.match(hostnamePartPattern)) {\n              var validParts = hostparts.slice(0, i);\n              var notHost = hostparts.slice(i + 1);\n              var bit = part.match(hostnamePartStart);\n              if (bit) {\n                validParts.push(bit[1]);\n                notHost.unshift(bit[2]);\n              }\n              if (notHost.length) {\n                rest = '/' + notHost.join('.') + rest;\n              }\n              this.hostname = validParts.join('.');\n              break;\n            }\n          }\n        }\n      }\n\n      if (this.hostname.length > hostnameMaxLen) {\n        this.hostname = '';\n      }\n      else {\n        // hostnames are always lower case.\n        this.hostname = this.hostname.toLowerCase();\n      }\n\n      if (!ipv6Hostname) {\n        // IDNA Support: Returns a punycoded representation of \"domain\".\n        // It only converts parts of the domain name that\n        // have non-ASCII characters, i.e. it doesn't matter if\n        // you call it with a domain that already is ASCII-only.\n        this.hostname = punycode.toASCII(this.hostname);\n      }\n\n      var p = this.port ? ':' + this.port : '';\n      var h = this.hostname || '';\n      this.host = h + p;\n      this.href += this.host;\n\n      // strip [ and ] from the hostname\n      // the host field still retains them, though\n      if (ipv6Hostname) {\n        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n        if (rest[0] !== '/') {\n          rest = '/' + rest;\n        }\n      }\n    }\n\n    // now rest is set to the post-host stuff.\n    // chop off any delim chars.\n    if (!unsafeProtocol[lowerProto]) {\n\n      // First, make 100% sure that any \"autoEscape\" chars get\n      // escaped, even if encodeURIComponent doesn't think they\n      // need to be.\n      for (var i = 0, l = autoEscape.length; i < l; i++) {\n        var ae = autoEscape[i];\n        if (rest.indexOf(ae) === -1) { continue; }\n        var esc = encodeURIComponent(ae);\n        if (esc === ae) {\n          esc = escape(ae);\n        }\n        rest = rest.split(ae).join(esc);\n      }\n    }\n\n\n    // chop off from the tail first.\n    var hash = rest.indexOf('#');\n    if (hash !== -1) {\n      // got a fragment string.\n      this.hash = rest.substr(hash);\n      rest = rest.slice(0, hash);\n    }\n    var qm = rest.indexOf('?');\n    if (qm !== -1) {\n      this.search = rest.substr(qm);\n      this.query = rest.substr(qm + 1);\n      if (parseQueryString) {\n        this.query = querystring.parse(this.query);\n      }\n      rest = rest.slice(0, qm);\n    }\n    else if (parseQueryString) {\n      // no query string, but parseQueryString still requested\n      this.search = '';\n      this.query = {};\n    }\n    if (rest) { this.pathname = rest; }\n    if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n      this.pathname = '/';\n    }\n\n    // to support http.request\n    if (this.pathname || this.search) {\n      var p = this.pathname || '';\n      var s = this.search || '';\n      this.path = p + s;\n    }\n\n    // finally, reconstruct the href based on what has been validated.\n    this.href = this.format();\n    return this;\n  };\n\n  // format a parsed object into a url string\n  function urlFormat (obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (util.isString(obj)) { obj = urlParse(obj); }\n    if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n    return obj.format();\n  }\n\n  Url.prototype.format = function () {\n    var auth = this.auth || '';\n    if (auth) {\n      auth = encodeURIComponent(auth);\n      auth = auth.replace(/%3A/i, ':');\n      auth += '@';\n    }\n\n    var protocol = this.protocol || '',\n        pathname = this.pathname || '',\n        hash = this.hash || '',\n        host = false,\n        query = '';\n\n    if (this.host) {\n      host = auth + this.host;\n    }\n    else if (this.hostname) {\n      host = auth + (this.hostname.indexOf(':') === -1\n        ? this.hostname\n        : '[' + this.hostname + ']');\n      if (this.port) {\n        host += ':' + this.port;\n      }\n    }\n\n    if (this.query &&\n        util.isObject(this.query) &&\n        Object.keys(this.query).length) {\n      query = querystring.stringify(this.query);\n    }\n\n    var search = this.search || (query && ('?' + query)) || '';\n\n    if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n    // unless they had them to begin with.\n    if (this.slashes ||\n        (!protocol || slashedProtocol[protocol]) && host !== false) {\n      host = '//' + (host || '');\n      if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n    }\n    else if (!host) {\n      host = '';\n    }\n\n    if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n    if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n    pathname = pathname.replace(/[?#]/g, function (match) {\n      return encodeURIComponent(match);\n    });\n    search = search.replace('#', '%23');\n\n    return protocol + host + pathname + search + hash;\n  };\n\n  function urlResolve (source, relative) {\n    return urlParse(source, false, true).resolve(relative);\n  }\n\n  Url.prototype.resolve = function (relative) {\n    return this.resolveObject(urlParse(relative, false, true)).format();\n  };\n\n  function urlResolveObject (source, relative) {\n    if (!source) { return relative; }\n    return urlParse(source, false, true).resolveObject(relative);\n  }\n\n  Url.prototype.resolveObject = function (relative) {\n    if (util.isString(relative)) {\n      var rel = new Url();\n      rel.parse(relative, false, true);\n      relative = rel;\n    }\n\n    var result = new Url();\n    var tkeys = Object.keys(this);\n    for (var tk = 0; tk < tkeys.length; tk++) {\n      var tkey = tkeys[tk];\n      result[tkey] = this[tkey];\n    }\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there's nothing left to do here.\n    if (relative.href === '') {\n      result.href = result.format();\n      return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative.protocol) {\n      // take everything except the protocol from relative\n      var rkeys = Object.keys(relative);\n      for (var rk = 0; rk < rkeys.length; rk++) {\n        var rkey = rkeys[rk];\n        if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n      }\n\n      // urlParse appends trailing / to urls like http://www.example.com\n      if (slashedProtocol[result.protocol] &&\n          result.hostname && !result.pathname) {\n        result.path = result.pathname = '/';\n      }\n\n      result.href = result.format();\n      return result;\n    }\n\n    if (relative.protocol && relative.protocol !== result.protocol) {\n      // if it's a known url protocol, then changing\n      // the protocol does weird things\n      // first, if it's not file:, then we MUST have a host,\n      // and if there was a path\n      // to begin with, then we MUST have a path.\n      // if it is file:, then the host is dropped,\n      // because that's known to be hostless.\n      // anything else is assumed to be absolute.\n      if (!slashedProtocol[relative.protocol]) {\n        var keys = Object.keys(relative);\n        for (var v = 0; v < keys.length; v++) {\n          var k = keys[v];\n          result[k] = relative[k];\n        }\n        result.href = result.format();\n        return result;\n      }\n\n      result.protocol = relative.protocol;\n      if (!relative.host && !hostlessProtocol[relative.protocol]) {\n        var relPath = (relative.pathname || '').split('/');\n        while (relPath.length && !(relative.host = relPath.shift())) { }\n        if (!relative.host) { relative.host = ''; }\n        if (!relative.hostname) { relative.hostname = ''; }\n        if (relPath[0] !== '') { relPath.unshift(''); }\n        if (relPath.length < 2) { relPath.unshift(''); }\n        result.pathname = relPath.join('/');\n      }\n      else {\n        result.pathname = relative.pathname;\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      result.host = relative.host || '';\n      result.auth = relative.auth;\n      result.hostname = relative.hostname || relative.host;\n      result.port = relative.port;\n      // to support http.request\n      if (result.pathname || result.search) {\n        var p = result.pathname || '';\n        var s = result.search || '';\n        result.path = p + s;\n      }\n      result.slashes = result.slashes || relative.slashes;\n      result.href = result.format();\n      return result;\n    }\n\n    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n        isRelAbs = (\n          relative.host ||\n            relative.pathname && relative.pathname.charAt(0) === '/'\n        ),\n        mustEndAbs = (isRelAbs || isSourceAbs ||\n                      (result.host && relative.pathname)),\n        removeAllDots = mustEndAbs,\n        srcPath = result.pathname && result.pathname.split('/') || [],\n        relPath = relative.pathname && relative.pathname.split('/') || [],\n        psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n      result.hostname = '';\n      result.port = null;\n      if (result.host) {\n        if (srcPath[0] === '') { srcPath[0] = result.host; }\n        else { srcPath.unshift(result.host); }\n      }\n      result.host = '';\n      if (relative.protocol) {\n        relative.hostname = null;\n        relative.port = null;\n        if (relative.host) {\n          if (relPath[0] === '') { relPath[0] = relative.host; }\n          else { relPath.unshift(relative.host); }\n        }\n        relative.host = null;\n      }\n      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n    }\n\n    if (isRelAbs) {\n      // it's absolute.\n      result.host = (relative.host || relative.host === '')\n        ? relative.host : result.host;\n      result.hostname = (relative.hostname || relative.hostname === '')\n        ? relative.hostname : result.hostname;\n      result.search = relative.search;\n      result.query = relative.query;\n      srcPath = relPath;\n      // fall through to the dot-handling below.\n    }\n    else if (relPath.length) {\n      // it's relative\n      // throw away the existing file, and take the new path instead.\n      if (!srcPath) { srcPath = []; }\n      srcPath.pop();\n      srcPath = srcPath.concat(relPath);\n      result.search = relative.search;\n      result.query = relative.query;\n    }\n    else if (!util.isNullOrUndefined(relative.search)) {\n      // just pull out the search.\n      // like href='?foo'.\n      // Put this after the other two cases because it simplifies the booleans\n      if (psychotic) {\n        result.hostname = result.host = srcPath.shift();\n        // occationaly the auth can get stuck only in host\n        // this especialy happens in cases like\n        // url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n        var authInHost = result.host && result.host.indexOf('@') > 0\n          ? result.host.split('@') : false;\n        if (authInHost) {\n          result.auth = authInHost.shift();\n          result.host = result.hostname = authInHost.shift();\n        }\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      // to support http.request\n      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') +\n                      (result.search ? result.search : '');\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    if (!srcPath.length) {\n      // no path at all.  easy.\n      // we've already handled the other stuff above.\n      result.pathname = null;\n      // to support http.request\n      if (result.search) {\n        result.path = '/' + result.search;\n      }\n      else {\n        result.path = null;\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    var last = srcPath.slice(-1)[0];\n    var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n        last === '');\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = srcPath.length; i >= 0; i--) {\n      last = srcPath[i];\n      if (last === '.') {\n        srcPath.splice(i, 1);\n      }\n      else if (last === '..') {\n        srcPath.splice(i, 1);\n        up++;\n      }\n      else if (up) {\n        srcPath.splice(i, 1);\n        up--;\n      }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n      for (; up--; up) {\n        srcPath.unshift('..');\n      }\n    }\n\n    if (mustEndAbs && srcPath[0] !== '' &&\n        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n      srcPath.unshift('');\n    }\n\n    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n      srcPath.push('');\n    }\n\n    var isAbsolute = srcPath[0] === '' ||\n        (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n    // put the host back\n    if (psychotic) {\n      result.hostname = result.host = isAbsolute ? ''\n        : srcPath.length ? srcPath.shift() : '';\n      // occationaly the auth can get stuck only in host\n      // this especialy happens in cases like\n      // url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0\n        ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n      srcPath.unshift('');\n    }\n\n    if (!srcPath.length) {\n      result.pathname = null;\n      result.path = null;\n    }\n    else {\n      result.pathname = srcPath.join('/');\n    }\n\n    // to support request.http\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  };\n\n  Url.prototype.parseHost = function () {\n    var host = this.host;\n    var port = portPattern.exec(host);\n    if (port) {\n      port = port[0];\n      if (port !== ':') {\n        this.port = port.substr(1);\n      }\n      host = host.substr(0, host.length - port.length);\n    }\n    if (host) { this.hostname = host; }\n  };\n\n}());\n",
    "'use strict';\n\nmodule.exports = OmniPath;\n\nvar path = require('./node/path'),\n    url = require('./node/url'),\n    util = require('./util'),\n    querystring = require('querystring'),\n    parts = ['protocol', 'slashes', 'hostname', 'port', 'host', 'dir', 'base',\n      'pathname', 'query', 'search', 'path', 'hash'];\n\n/**\n * A parsed URL or file path. This object has the same properties as a parsed URL (via {@link url.parse},\n * plus the properties of a parsed file path (via {@link path.parse}.\n *\n * Parsed URL:  {@link https://nodejs.org/api/url.html#url_url}\n * Parsed Path: {@link https://nodejs.org/api/path.html#path_path_parse_pathstring}\n *\n * @param {string|Url|OmniPath} p         - The file path or URL to parse.\n * @param {PathOptions}         [options] - Options that determine how paths are parsed\n * @constructor\n */\nfunction OmniPath (p, options) {\n  // If it's already an OmniPath, then just clone it as-is\n  if (p instanceof OmniPath) {\n    return p.clone(options);\n  }\n\n  p = util.toString(p);\n  var type = util.getType(p);\n\n  if (type.isUrl) {\n    return new OmniPath.Url(p, options);\n  }\n  else if (type.isWindows) {\n    return new OmniPath.Windows(p, options);\n  }\n  else {\n    return new OmniPath.Posix(p, options);\n  }\n}\n\n// Create fast shortcut methods for the basic type checks\n['isUrl', 'isPosix', 'isWindows'].forEach(function (prop) {\n  OmniPath[prop] = function (p) {\n    if (p instanceof OmniPath) {\n      return p[prop];\n    }\n    return !!util.getType(p)[prop];\n  };\n});\n\n// Create shortcut methods for all OmniPath properties\nutil.props.forEach(function (prop) {\n  if (OmniPath[prop] === undefined) {\n    OmniPath[prop] = function (p, options) {\n      var Class = this;\n      var omniPath = new Class(p, options);\n      return omniPath[prop];\n    };\n  }\n});\n\n/**\n * Returns the directory name of the given path or URL. Like Node's {@link path.dirname}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_dirname_p}\n *\n * @param   {string|Url|OmniPath}  p          - The file path or URL to parse\n * @param   {PathOptions}          [options]  - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.dirname = function (p, options) {\n  var Class = this;\n  var omniPath = new Class(p, options);\n  return omniPath.dirname();\n};\n\n/**\n * Returns the directory name of the given path or URL. Like Node's {@link path.dirname}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_dirname_p}\n *\n * @returns {string}\n */\nOmniPath.prototype.dirname = function () {\n  return this._path.dirname(this.pathname);\n};\n\n/**\n * Returns the last portion of the given path or URL. Like Node's {@link path.basename}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_basename_p_ext}\n *\n * @param   {string|Url|OmniPath}  p          - The file path or URL to parse\n * @param   {string}               [ext]      - The portion of the file extension to leave off\n * @param   {PathOptions}          [options]  - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.basename = function (p, ext, options) {\n  if (typeof (ext) === 'object') {\n    options = ext;\n    ext = undefined;\n  }\n  var Class = this;\n  var omniPath = new Class(p, options);\n  return omniPath.basename(ext);\n};\n\n/**\n * Returns the last portion of the given path or URL. Like Node's {@link path.basename}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_basename_p_ext}\n *\n * @param   {string} [ext] - The portion of the file extension to leave off\n * @returns {string}\n */\nOmniPath.prototype.basename = function (ext) {\n  return this._path.basename(this.base, ext);\n};\n\n/**\n * Returns the extension of the given path or URL. Like Node's {@link path.extname}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_extname_p}\n *\n * @param   {string|Url|OmniPath}  p          - The file path or URL to parse\n * @param   {PathOptions}          [options]  - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.extname = OmniPath.ext;\n\n/**\n * Returns the extension of the given path or URL. Like Node's {@link path.extname}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_extname_p}\n *\n * @returns {string}\n */\nOmniPath.prototype.extname = function () {\n  return this.ext;\n};\n\n/**\n * Joins all arguments together, and normalizes the resulting path. Like Node's {@link path.join}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_join_path1_path2}\n *\n * @param   {...string|...Url|...OmniPath}  p         - The paths (or segments) to join\n * @param   {PathOptions}                   [options] - Options that determine how paths are parsed\n * @returns {string}\n * @abstract\n */\nOmniPath.join = function (p, options) {\n  return callSubclassMethod('join', arguments);\n};\n\n/**\n * Joins all arguments to this path, and normalizes the resulting path. Like Node's {@link path.join}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_join_path1_path2}\n *\n * @param   {...string|...Url|...OmniPath}  p       - The paths (or segments) to join to this path\n * @param   {PathOptions}                   options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.prototype.join = function (p, options) {\n  var args = [this].concat(Array.prototype.slice.call(arguments));\n  var parsed = util.fastParse(args, false, true);\n  var joined = this._path.join.apply(this._path, parsed.pathnames);\n\n  // If the last segment has a query/hash, then append it\n  var lastSearch = parsed.searches[parsed.last];\n  var lastHash = parsed.hashes[parsed.last];\n  return joined + lastSearch + lastHash;\n};\n\n/**\n * Resolves `to` to an absolute path. Like Node's {@link path.resolve} or {@link url.resolve}.\n *\n * path.resolve: {@link https://nodejs.org/api/path.html#path_path_resolve_from_to}\n * url.resolve {@link https://nodejs.org/api/url.html#url_url_resolve_from_to}\n *\n * @param   {string|Url|OmniPath}           from    - The file path or URL to resolve from.\n * @param   {...string|...Url|...OmniPath}  to      - The path(s) to resolve, relative to `from`.\n * @param   {PathOptions}                   options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.resolve = function (from, to, options) {\n  return callSubclassMethod('resolve', arguments);\n};\n\n/**\n * Resolves `to` to an absolute path. Like Node's {@link path.resolve} or {@link url.resolve}.\n *\n * path.resolve:  {@link https://nodejs.org/api/path.html#path_path_resolve_from_to}\n * url.resolve    {@link https://nodejs.org/api/url.html#url_url_resolve_from_to}\n *\n * @param   {...string|...Url|...OmniPath}  to      - The path(s) to resolve, relative to this one.\n * @param   {PathOptions}                   options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.prototype.resolve = function (to, options) {\n  var args = [this].concat(Array.prototype.slice.call(arguments));\n  var parsed = util.fastParse(args);\n  var pathnames = parsed.pathnames;\n\n  if (parsed.hasUrls) {\n    // If any of the paths are URLs, then use URL-resolving logic\n    return OmniPath.Url.resolve.apply(OmniPath.Url, parsed.hrefs);\n  }\n\n  if (process.browser) {\n    // Use OmniPath.cwd() instead of Browserify's process.cwd() (which is always \"/\")\n    pathnames = [OmniPath.cwd()].concat(parsed.pathnames);\n  }\n\n  // Resolve the path\n  var resolved = this._path.resolve.apply(this._path, pathnames);\n\n  // Resolve the search and hash\n  var search = '', hash = '';\n  for (var i = 0; i <= parsed.last; i++) {\n    if (parsed.searches[i]) {\n      search = parsed.searches[i];\n      hash = parsed.hashes[i];\n    }\n    else if (parsed.hashes[i]) {\n      hash = parsed.hashes[i];\n    }\n  }\n\n  return resolved + search + hash;\n};\n\n/**\n * Normalizes a path, resolving any \".\" and \"..\" segments, eliminating redundant slashes,\n * and standardizing slashes. Like Node's {@link path.normalize}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_normalize_p}\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to format\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.normalize = function (p, options) {\n  var Class = this;\n  return new Class(p, options).normalize();\n};\n\n/**\n * Normalizes the path, resolving any \".\" and \"..\" segments, eliminating redundant slashes,\n * and standardizing slashes. Like Node's {@link path.normalize}.\n *\n * {@link https://nodejs.org/api/path.html#path_path_normalize_p}\n *\n * @returns {string}\n */\nOmniPath.prototype.normalize = function () {\n  var formatted = this.pathname || this._path.format(this);\n  var normalized = this._path.normalize(formatted);\n  var searchAndHash = this._getFormattedSearchAndHash();\n  return normalized + searchAndHash;\n};\n\n/**\n * Returns the given path or URL as a formatted string. Like Node's {@link path.format} or {@link url.format}.\n *\n * path.format: {@link https://nodejs.org/api/path.html#path_path_format_pathobject}\n * url.format:  {@link https://nodejs.org/api/url.html#url_url_format_urlobj}\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to format\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.format = function (p, options) {\n  var Class = this;\n  return new Class(p, options).format();\n};\n\n/**\n * Returns the formatted path or URL string. Like Node's {@link path.format} or {@link url.format}.\n *\n * path.format: {@link https://nodejs.org/api/path.html#path_path_format_pathobject}\n * url.format:  {@link https://nodejs.org/api/url.html#url_url_format_urlobj}\n *\n * @returns {string}\n */\nOmniPath.prototype.format = function () {\n  var pathname = this._path.format(this);\n  var searchAndHash = this._getFormattedSearchAndHash();\n  return pathname + searchAndHash;\n};\n\n/**\n * Returns the specified part(s) of the given path or URL as a formatted string.\n *\n * @param   {string|Url|OmniPath}   p\n * - The file path or URL to format\n *\n * @param   {string} part\n * - The name of the rightmost part to include in the returned string.\n * For example, \"protocol\" will only return the protocol part,\n * whereas \"port\" will return the protocol, slashes, auth, hostname, and port.\n *\n * @param   {PathOptions} [options]\n * - Options that determine how paths are parsed\n *\n * @returns {string}\n */\nOmniPath.formatPart = function (p, part, options) {\n  var Class = this;\n  return new Class(p, options).formatPart(part);\n};\n\n/**\n * Returns the specified part(s) of the path or URL as a formatted string.\n *\n * @param   {string} part\n * - The name of the rightmost part to include in the returned string.\n * For example, \"protocol\" will only return the protocol part,\n * whereas \"port\" will return the protocol, slashes, auth, hostname, and port.\n *\n * @returns {string}\n */\nOmniPath.prototype.formatPart = function (part) {\n  part = parts.indexOf(part);\n  var clone = this.clone();\n  part < 0 && (clone.protocol = '');\n  part < 1 && (clone.slashes = false);\n  part < 2 && (clone.hostname = '');\n  part < 3 && (clone.port = '');\n  part < 4 && (clone.host = '');\n  part < 5 && (clone.dir = '');\n  part < 6 && (clone.base = '');\n  part < 7 && (clone.pathname = '');\n  part < 8 && (clone.query = '');\n  part < 9 && (clone.search = '');\n  part < 10 && (clone.path = '');\n  part < 11 && (clone.hash = '');\n  return clone.format();\n};\n\n/**\n * Returns the formatted path or URL string, by calling {@link OmniPath#format}.\n *\n * @type {Function}\n */\nOmniPath.prototype.toString = OmniPath.prototype.format;\n\n/**\n * Returns the primitive string value, by calling {@link OmniPath#format}.\n *\n * @type {Function}\n */\nOmniPath.prototype.valueOf = OmniPath.prototype.format;\n\n/**\n * Returns the given path or URL as a {@link Url} object. File paths will be returned as \"file://\" URLs.\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to format\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @returns {Url}\n */\nOmniPath.toUrl = function (p, options) {\n  var Class = this;\n  return new Class(p, options).toUrl();\n};\n\n/**\n * Returns the path or URL as a {@link Url} object. If {@link OmniPath#isFS} is true,\n * then the returned value will be a \"file://\" URL.\n *\n * @returns {Url}\n */\nOmniPath.prototype.toUrl = function () {\n  return url.parse(this.toUrlString(), true);\n};\n\n/**\n * Returns the given path or URL to a formatted URL string. File paths will be returned as \"file://\" URLs.\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to format\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPath.toUrlString = function (p, options) {\n  var Class = this;\n  return new Class(p, options).toUrlString();\n};\n\n/**\n * Returns a formatted URL string. If {@link OmniPath#isFS} is true, then the returned value\n * will be a \"file://\" URL.\n *\n * @returns {string}\n */\nOmniPath.prototype.toUrlString = function () {\n  var hostname = this.hostname;\n  var pathname = this.pathname;\n  var search = this.search;\n  var hash = this.hash;\n\n  // Encode backslash characters\n  pathname = pathname.replace(util.backslashPattern, '%5C');\n  search = search.replace(util.backslashPattern, '%5C');\n  hash = hash.replace(util.backslashPattern, '%5C');\n\n  // Format the file path as a URL\n  var formatted = url.format({\n    protocol: 'file:',\n    slashes: true,\n    hostname: hostname,\n    pathname: pathname,\n    search: search,\n    hash: hash\n  });\n\n  // Parse the formatted URL, to encode any special characters\n  var parsed = url.parse(formatted);\n\n  // Re-format the URL, this time with encoding\n  // noinspection UnnecessaryLocalVariableJS\n  var encoded = parsed.format();\n  return encoded;\n};\n\n/**\n * Returns the current working directory. If running in a web browser, then the working directory\n * is based on the current page's URL.\n *\n * The returned path always includes a trailing slash, which ensures that it behaves properly\n * with methods like {@link url.resolve}.\n *\n * @returns {string}\n */\nOmniPath.cwd = function () {\n  if (process.browser) {\n    var u = new OmniPath.Url(window.location.href);\n    var dir = u.formatPart('dir');\n    if (dir.substr(-1) !== OmniPath.Url.sep) {\n      dir += OmniPath.Url.sep;\n    }\n    return dir;\n  }\n  else {\n    return process.cwd() + path.sep;\n  }\n};\n\n/**\n * Parses the given path or URL, and returns a {@link OmniPath} object. Like Node's\n * {@link path.parse} and {@link url.parse}.\n *\n * path.parse: {@link https://nodejs.org/api/path.html#path_path_parse_pathstring}\n * url.parse:  {@link https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost}\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to parse\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @returns {OmniPath}\n */\nOmniPath.parse = function (p, options) {\n  var Class = this;\n  return new Class(p, options);\n};\n\n/**\n * Parses the given path or URL, and sets the corresponding properties of this {@link OmniPath} object.\n * Like Node's {@link path.parse} and {@link url.parse}.\n *\n * path.parse: {@link https://nodejs.org/api/path.html#path_path_parse_pathstring}\n * url.parse:  {@link https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost}\n *\n * @param   {string|Url|OmniPath}   p         - The file path or URL to parse\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n * @abstract\n */\nOmniPath.prototype.parse = function (p, options) {\n  // If the path is already parsed, then just copy it\n  if (p instanceof this.constructor) {\n    util.copy(p, this);\n    this._options = options || p._options || this._options;\n    return;\n  }\n\n  // Reset everything\n  this.isUrl = false;\n  this.isFS = false;\n  this.isPosix = false;\n  this.isWindows = false;\n  this.isUnc = false;\n  this.isAbsolute = false;\n  this.sep = '';\n  this.delimiter = '';\n  this.href = '';\n  this.protocol = '';\n  this.slashes = false;\n  this.auth = '';\n  this.host = '';\n  this.hostname = '';\n  this.port = '';\n  this.path = '';\n  this.pathname = '';\n  this.root = '';\n  this.dir = '';\n  this.base = '';\n  this.name = '';\n  this.ext = '';\n  this.search = '';\n  this.query = {};\n  this.hash = '';\n\n  /** @protected */\n  this._options = options || this._options || (p && p._options);\n\n  // Return the path to be parsed by an OmniPath subclass\n  return util.toString(p);\n};\n\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\nOmniPath.prototype.toJSON = function () {\n  var json = {};\n  for (var i = 0; i < util.props.length; i++) {\n    var prop = util.props[i];\n    json[prop] = this[prop];\n  }\n  return json;\n};\n\n/**\n * Creates a clone of this {@link OmniPath} object.\n *\n * @param {PathOptions} [options] - Options that determine how paths are parsed\n * @returns {OmniPath}\n */\nOmniPath.prototype.clone = function (options) {\n  var Class = this.constructor;\n  return new Class(this, options);\n};\n\n/**\n * Returns the formatted {@link OmniPath#search} and {@link OmniPath#hash}.\n * If {@link OmniPath#search} is empty, then {@link OmniPath#query} is used instead.\n *\n * @returns {string}\n * @private\n */\nOmniPath.prototype._getFormattedSearchAndHash = function () {\n  var search = this.search || '';\n  var hash = this.hash || '';\n\n  if (search) {\n    if (search[0] !== '?') {\n      search = '?' + search;\n    }\n  }\n  else if (this.query) {\n    // Build the `search` property from the `query` property\n    var query = querystring.stringify(this.query);\n    if (query) {\n      search = '?' + query;\n    }\n  }\n\n  // If the file has a hash, then format the `hash` property\n  if (hash && hash[0] !== '#') {\n    hash = '#' + hash;\n  }\n\n  return search + hash;\n};\n\n/**\n * Passes the given arguments to the specified method of an {@link OmniPath} subclass,\n * based on the first argument's type.\n *\n * @param {string} method - The method to call\n * @param {Arguments} args - The arguments to pass to the method\n */\nfunction callSubclassMethod (method, args) {\n  var type = util.getType(args[0]);\n  if (type.isUrl) {\n    return OmniPath.Url[method].apply(OmniPath.Url, args);\n  }\n  else if (type.isWindows) {\n    return OmniPath.Windows[method].apply(OmniPath.Windows, args);\n  }\n  else {\n    return OmniPath.Posix[method].apply(OmniPath.Posix, args);\n  }\n}\n",
    "'use strict';\n\nmodule.exports = OmniPosix;\n\nvar posix = require('./node/path').posix,\n    OmniPath = require('./index'),\n    util = require('./util');\n\n/**\n * An {@link OmniPath} subclass that always treats paths as POSIX paths.\n *\n * @constructor\n */\nfunction OmniPosix (p, options) {\n  if (!(this instanceof OmniPosix)) {\n    throw new TypeError('Use the \"new\" keyword when creating an instance of OmniPath.Posix');\n  }\n\n  this._path = posix;\n  this.parse(p, options);\n}\n\nutil.inherits(OmniPosix, OmniPath);\nOmniPosix.sep = posix.sep;\nOmniPosix.delimiter = posix.delimiter;\n\n// Override the basic type checks\nOmniPosix.isUrl = function () { return false; };\nOmniPosix.isPosix = function () { return true; };\nOmniPosix.isWindows = function () { return false; };\n\n/**\n * Parses the given path as a POSIX path, and sets the corresponding properties of this {@link OmniPosix} object.\n *\n * @param   {string|Url|OmniPosix}  p         - The file path or URL to parse\n * @param   {PathOptions}           [options] - Options that determine how paths are parsed\n */\nOmniPosix.prototype.parse = function (p, options) {\n  p = OmniPath.prototype.parse.apply(this, arguments);\n  if (typeof (p) === 'string') {\n    var split = util.parsePath(p, this._options);\n    var parsed = posix.parse(split.pathname);\n\n    this.isFS = true;\n    this.isPosix = true;\n    this.isAbsolute = posix.isAbsolute(split.pathname);\n    this.sep = posix.sep;\n    this.delimiter = posix.delimiter;\n    this.href = p;\n    this.path = split.pathname + split.search;\n    this.pathname = split.pathname;\n    this.root = parsed.root;\n    this.dir = parsed.dir;\n    this.base = parsed.base;\n    this.name = parsed.name;\n    this.ext = parsed.ext;\n    this.search = split.search;\n    this.query = split.query;\n    this.hash = split.hash;\n  }\n  return this;\n};\n\n/**\n * Joins all arguments together, and normalizes the resulting path.\n *\n * @param   {...string|...Url|...OmniPath}  p         - The paths (or segments) to join\n * @param   {PathOptions}                   [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPosix.join = function (p, options) {\n  return OmniPath.prototype.join.apply({ _path: posix, href: '' }, arguments);\n};\n\n/**\n * Resolves `to` to an absolute path.\n *\n * @param   {string|Url|OmniPath} from    - The file path or URL to resolve from.\n * @param   {string|Url|OmniPath} to      - The file path or URL to resolve, relative to `from`.\n * @param   {PathOptions}         options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniPosix.resolve = function (from, to, options) {\n  return OmniPath.prototype.resolve.apply({ _path: posix, href: '' }, arguments);\n};\n\n/**\n * Returns the current working directory, formatted as a POSIX path.\n *\n * @returns {string}\n */\nOmniPosix.cwd = function () {\n  var cwd = OmniPath.cwd();\n  return posix.normalize(cwd);\n};\n",
    "'use strict';\n\nmodule.exports = OmniUrl;\n\nvar posix = require('./node/path').posix,\n    url = require('./node/url'),\n    OmniPath = require('./omni-path'),\n    util = require('./util'),\n    slashesPattern = /^\\/*/,\n    looseProtocolPattern = /^[a-z0-9.+-]+:/i;\n\n/**\n * An {@link OmniPath} subclass that always treats paths as URLs.\n *\n * @constructor\n */\nfunction OmniUrl (p, options) {\n  if (!(this instanceof OmniUrl)) {\n    throw new TypeError('Use the \"new\" keyword when creating an instance of OmniPath.Url');\n  }\n\n  this._path = posix;\n  this.parse(p, options);\n}\n\nutil.inherits(OmniUrl, OmniPath);\nOmniUrl.sep = posix.sep;\n\n// Override the basic type checks\nOmniUrl.isUrl = function () { return true; };\nOmniUrl.isPosix = function () { return false; };\nOmniUrl.isWindows = function () { return false; };\n\n/**\n * Parses the given path as a URL, and sets the corresponding properties of this {@link OmniUrl} object.\n *\n * @param   {string|Url|OmniUrl}  p         - The file path or URL to parse\n * @param   {PathOptions}         [options] - Options that determine how paths are parsed\n */\nOmniUrl.prototype.parse = function (p, options) {\n  p = OmniPath.prototype.parse.apply(this, arguments);\n  if (typeof (p) === 'string') {\n    var parsedUrl = url.parse(p, true);\n    var parsedPath = posix.parse(parsedUrl.pathname || '');\n\n    this.isUrl = true;\n    this.isAbsolute = !!parsedUrl.protocol || !!parsedUrl.host || posix.isAbsolute(parsedUrl.pathname || '');\n    this.sep = posix.sep;\n    this.href = parsedUrl.href || '';\n    this.protocol = parsedUrl.protocol || '';\n    this.slashes = parsedUrl.slashes || false;\n    this.auth = parsedUrl.auth || '';\n    this.host = parsedUrl.host || '';\n    this.hostname = parsedUrl.hostname || '';\n    this.port = parsedUrl.port || '';\n    this.path = parsedUrl.path || '';\n    this.pathname = parsedUrl.pathname || '';\n    this.root = parsedPath.root;\n    this.dir = parsedPath.dir;\n    this.base = parsedPath.base;\n    this.name = parsedPath.name;\n    this.ext = parsedPath.ext;\n    this.search = parsedUrl.search || '';\n    this.query = parsedUrl.query || {};\n    this.hash = parsedUrl.hash || '';\n  }\n  return this;\n};\n\n/**\n * Normalizes the URL, resolving any \".\" and \"..\" segments, eliminating redundant slashes,\n * and standardizing slashes.\n *\n * @returns {string}\n */\nOmniUrl.prototype.normalize = function () {\n  var formatted = this.pathname || this._getFormattedPathname();\n  var normalized = posix.normalize(formatted);\n\n  var pathnameIsBlank = false;\n  if (normalized === '.') {\n    // Special case for URLs without a pathname\n    normalized = '';\n    pathnameIsBlank = true;\n  }\n\n  var clone = this.clone();\n  clone.pathname = normalized;\n  formatted = url.format(clone);\n\n  if (formatted === '' && pathnameIsBlank) {\n    // Special case for URLs that resolve to cwd (\"\", \".\", \"././.\", etc.)\n    return '.';\n  }\n  else {\n    return formatted;\n  }\n};\n\n/**\n * Returns the formatted path or URL string.\n *\n * @returns {string}\n */\nOmniUrl.prototype.format = function () {\n  var clone = this.clone();\n  clone.pathname = this._getFormattedPathname();\n  return url.format(clone);\n};\n\n/**\n * Returns a formatted URL string.\n *\n * @returns {string}\n */\nOmniUrl.prototype.toUrlString = function () {\n  return url.format(this);\n};\n\n/**\n * Joins all arguments together, and normalizes the resulting path.\n *\n * @param   {...string|...Url|...OmniPath}  p         - The paths (or segments) to join\n * @param   {PathOptions}                   [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniUrl.join = function (p, options) {\n  var parsed = util.fastParse(arguments, true);\n  var joined = parsed.pathnames[0];\n\n  for (var i = 1; i < parsed.pathnames.length; i++) {\n    var segment = parsed.pathnames[i];\n    if (segment) {\n      // Ignore segments that are blank or separators\n      if (segment === posix.sep || segment === '\\\\') {\n        // If the LAST segment is a separator, then it matters\n        if (i === parsed.pathnames.length - 1) {\n          joined += posix.sep;\n        }\n      }\n      else if (util.endsWithAnySeparator(joined) || util.startsWithAnySeparator(segment)) {\n        joined += segment;\n      }\n      else {\n        joined += posix.sep + segment;\n      }\n    }\n  }\n\n  // If the last segment has a query/hash, then append it\n  var lastSearch = parsed.searches[parsed.last];\n  var lastHash = parsed.hashes[parsed.last];\n  joined += lastSearch + lastHash;\n\n  var omniUrl = new OmniUrl(joined);\n  return omniUrl.normalize();\n};\n\n/**\n * Joins all arguments to this path, and normalizes the resulting path.\n *\n * @param   {...string|...Url|...OmniPath}  p         - The paths (or segments) to join\n * @param   {PathOptions}                   [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniUrl.prototype.join = function (p, options) {\n  return OmniUrl.join.apply(OmniUrl, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\n/**\n * Resolves `to` to an absolute path.\n *\n * @param   {string|Url|OmniPath} from    - The file path or URL to resolve from.\n * @param   {string|Url|OmniPath} to      - The file path or URL to resolve, relative to `from`.\n * @param   {PathOptions}         options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniUrl.resolve = function (from, to, options) {\n  var args = util.getArgs(arguments);\n  var paths = args.paths;\n  to = util.toString(paths[paths.length - 1]);\n\n  for (var i = paths.length - 2; i >= 0; i--) {\n    from = util.toString(paths[i]);\n    to = url.resolve(from, to);\n\n    if (looseProtocolPattern.test(to)) {\n      // We have an absolute path, so no need to continue processing\n      return to;\n    }\n  }\n\n  return url.resolve(OmniPath.cwd(), to);\n};\n\n/**\n * Resolves `to` to an absolute path. Like Node's {@link path.resolve} or {@link url.resolve}.\n *\n * @param   {...string|...Url|...OmniPath}  to      - The path(s) to resolve, relative to this one.\n * @param   {PathOptions}                   options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniUrl.prototype.resolve = function (to, options) {\n  return OmniUrl.resolve.apply(OmniUrl, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\n/**\n * Returns the current working directory, formatted as a URL.\n *\n * @returns {string}\n */\nOmniUrl.cwd = function () {\n  var cwd = OmniPath.cwd();\n  return OmniUrl.normalize(cwd);\n};\n\n/**\n * Returns the formatted pathname by combining {@link OmniUrl#dir} and {@link OmniUrl#base}.\n *\n * @returns {string}\n * @private\n */\nOmniUrl.prototype._getFormattedPathname = function () {\n  var pathname = this.pathname;\n\n  if (this.dir || this.base) {\n    var oldPathname = pathname;\n\n    if (this.dir === this.sep) {\n      // Special case for root paths, to match `url.format()` behavior\n      var slashes = slashesPattern.exec(this.pathname) || [''];\n      pathname = slashes[0] + this.base;\n    }\n    else {\n      pathname = posix.format(this);\n    }\n\n    // Maintain any trailing slash on the pathname, for consistency with Node's \"url\" module\n    if (util.endsWithAnySeparator(oldPathname) && !util.endsWithAnySeparator(pathname)) {\n      pathname += posix.sep;\n    }\n  }\n\n  return pathname;\n};\n",
    "'use strict';\n\nmodule.exports = OmniWindows;\n\nvar win32 = require('./node/path').win32,\n    OmniPath = require('./index'),\n    util = require('./util'),\n    uncPattern = /^[\\\\\\/]{2}([^\\\\\\/]+)[\\\\\\/]+[^\\\\\\/]+/, // This matches Node 0.12.7\n    splitUncPattern = /^\\/+([^\\/]+)(.*)/;\n\n/**\n * An {@link OmniPath} subclass that always treats paths as Windows paths.\n *\n * @constructor\n */\nfunction OmniWindows (p, options) {\n  if (!(this instanceof OmniWindows)) {\n    throw new TypeError('Use the \"new\" keyword when creating an instance of OmniPath.Windows');\n  }\n\n  this._path = win32;\n  this.parse(p, options);\n}\n\nutil.inherits(OmniWindows, OmniPath);\nOmniWindows.sep = win32.sep;\nOmniWindows.delimiter = win32.delimiter;\n\n// Override the basic type checks\nOmniWindows.isUrl = function () { return false; };\nOmniWindows.isPosix = function () { return false; };\nOmniWindows.isWindows = function () { return true; };\n\n/**\n * Parses the given path as a WINDOWS path, and sets the corresponding properties of this {@link OmniWindows} object.\n *\n * @param   {string|Url|OmniWindows}  p         - The file path or URL to parse\n * @param   {PathOptions}             [options] - Options that determine how paths are parsed\n */\nOmniWindows.prototype.parse = function (p, options) {\n  p = OmniPath.prototype.parse.apply(this, arguments);\n  if (typeof (p) === 'string') {\n    var split = util.parsePath(p, this._options);\n    var parsed = win32.parse(split.pathname);\n    var unc = uncPattern.exec(split.pathname);\n\n    this.isFS = true;\n    this.isWindows = true;\n    this.isAbsolute = win32.isAbsolute(split.pathname);\n    this.isUnc = !!unc;\n    this.sep = win32.sep;\n    this.delimiter = win32.delimiter;\n    this.href = p;\n    this.path = split.pathname + split.search;\n    this.pathname = split.pathname;\n    this.root = parsed.root;\n    this.dir = parsed.dir;\n    this.base = parsed.base;\n    this.name = parsed.name;\n    this.ext = parsed.ext;\n    this.search = split.search;\n    this.query = split.query;\n    this.hash = split.hash;\n\n    if (this.isUnc) {\n      // Set the UNC host\n      this.host = this.hostname = unc[1];\n    }\n  }\n  return this;\n};\n\n/**\n * Returns the formatted path or URL string.\n *\n * @returns {string}\n */\nOmniWindows.prototype.format = function () {\n  if (this.isUnc && (this.host || this.hostname) && !this.dir && !this.base) {\n    // Special case for UNCs with only a host\n    return '\\\\\\\\' + (this.hostname || this.host);\n  }\n  return OmniPath.prototype.format.apply(this, arguments);\n};\n\n/**\n * Returns a formatted URL string.\n *\n * @returns {string}\n */\nOmniWindows.prototype.toUrlString = function () {\n  var clone = this.clone();\n\n  // Convert Windows path separators to forward slashes\n  clone.pathname = clone.pathname.replace(util.backslashPattern, '/');\n\n  if (this.isUnc) {\n    var split = splitUncPattern.exec(clone.pathname);\n    if (split) {\n      clone.hostname = split[1];\n      clone.pathname = split[2] || '/';\n    }\n  }\n\n  return OmniPath.prototype.toUrlString.apply(clone, arguments);\n};\n\n/**\n * Joins all arguments together, and normalizes the resulting path.\n *\n * @param   {...string|...Url|...OmniPath}  p         - The paths (or segments) to join\n * @param   {PathOptions}                   [options] - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniWindows.join = function (p, options) {\n  return OmniPath.prototype.join.apply({ _path: win32, href: '' }, arguments);\n};\n\n/**\n * Resolves `to` to an absolute path.\n *\n * @param   {string|Url|OmniPath} from    - The file path or URL to resolve from.\n * @param   {string|Url|OmniPath} to      - The file path or URL to resolve, relative to `from`.\n * @param   {PathOptions}         options - Options that determine how paths are parsed\n * @returns {string}\n */\nOmniWindows.resolve = function (from, to, options) {\n  return OmniPath.prototype.resolve.apply({ _path: win32, href: '' }, arguments);\n};\n\n/**\n * Returns the current working directory, formatted as a Windows path.\n *\n * @returns {string}\n */\nOmniWindows.cwd = function () {\n  var cwd = OmniPath.cwd();\n  return win32.normalize(cwd);\n};\n",
    "'use strict';\n\nvar util = module.exports = {\n  props: [\n    'isUrl', 'isFS', 'isPosix', 'isWindows', 'isUnc', 'isAbsolute', 'sep', 'delimiter',\n    'href', 'protocol', 'slashes', 'auth', 'host', 'hostname', 'port', 'path', 'pathname',\n    'root', 'dir', 'base', 'name', 'ext', 'search', 'query', 'hash'\n  ],\n  backslashPattern: /\\\\/g,\n  isString: isString,\n  isObject: isObject,\n  isNull: isNull,\n  isNullOrUndefined: isNullOrUndefined,\n  toString: toString,\n  inherits: inherits,\n  copy: copy,\n  getType: getType,\n  parsePath: parsePath,\n  fastParse: fastParse,\n  getArgs: getArgs,\n  startsWithAnySeparator: startsWithAnySeparator,\n  endsWithAnySeparator: endsWithAnySeparator\n};\n\nvar OmniPath = require('./omni-path'),\n    url = require('./node/url'),\n    querystring = require('querystring'),\n    protocolPattern = /^[a-z0-9.+-]+:\\/\\//i;\n\n/**\n * Returns true if the given value is a string.\n *\n * @param {*} arg - The value to check\n * @returns {boolean}\n */\nfunction isString (arg) {\n  return typeof (arg) === 'string';\n}\n\n/**\n * Returns true if the given value is an object.\n *\n * @param {*} arg - The value to check\n * @returns {boolean}\n */\nfunction isObject (arg) {\n  return typeof (arg) === 'object' && arg !== null;\n}\n\n/**\n * Returns true if the given value is null.\n *\n * @param {*} arg - The value to check\n * @returns {boolean}\n */\nfunction isNull (arg) {\n  return arg === null;\n}\n\n/**\n * Returns true if the given value is null or undefined.\n *\n * @param {*} arg - The value to check\n * @returns {boolean}\n */\nfunction isNullOrUndefined (arg) {\n  return arg == null;\n}\n\n/**\n * Returns the given path a a string\n *\n * @param   {string|Url|OmniPath} p - The file path or URL to format.\n * @returns {string}\n */\nfunction toString (p) {\n  if (typeof (p) === 'string') {\n    return p;\n  }\n  else if (p instanceof url.Url) {\n    return p.format();\n  }\n  else if (p instanceof OmniPath) {\n    return p.format();\n  }\n  else if (p && typeof (p.href) === 'string') {\n    return p.href;\n  }\n\n  throw new Error('Expected a file path or URL, but got ' + typeof (p) + ' ' + p);\n}\n\n/**\n * Inherits the static and prototype methods of a superclass on a subclass.\n *\n * @param {Class} Child - The class that inherits from Super\n * @param {Class} Super - The parent class\n */\nfunction inherits (Child, Super) {\n  Child.prototype = Object.create(Super.prototype);\n  Child.prototype.constructor = Child;\n\n  var staticMembers = Object.keys(Super);\n  staticMembers.forEach(function (staticMember) {\n    if (typeof (Super[staticMember]) === 'function') {\n      Child[staticMember] = function () {\n        return Super[staticMember].apply(Child, arguments);\n      };\n    }\n    else {\n      Child[staticMember] = Super[staticMember];\n    }\n  });\n}\n\n/**\n * Copies the properties of one {@link OmniPath} object to another.\n *\n * @param   {OmniPath} src   - The source object, whose properties will be copied\n * @param   {OmniPath} dest  - The destination object, whose properties will be set\n * @returns {OmniPath}\n */\nfunction copy (src, dest) {\n  // Copy all public properties\n  for (var i = 0; i < util.props.length; i++) {\n    var prop = util.props[i];\n    dest[prop] = src[prop];\n  }\n\n  return dest;\n}\n\n/**\n * Determines the type of the given path.\n *\n * @param   {*} p - The path to inspect. Will be coerced to a string if necessary.\n * @returns {object}\n */\nfunction getType (p) {\n  if (p instanceof OmniPath) {\n    return p;\n  }\n  else if (typeof (p) !== 'string') {\n    p = toString(p);\n  }\n\n  // If the path starts with a protocol, then treat it as a URL,\n  // regardless of the runtime environment, and even if the path\n  // could also be a valid filesystem path for the environment.\n  if (protocolPattern.test(p)) {\n    return { isUrl: true };\n  }\n\n  // Parse the path based on the runtime environment\n  if (process.browser) {\n    return { isUrl: true };\n  }\n  else if (process.platform === 'win32') {\n    return { isWindows: true };\n  }\n  else {\n    return { isPosix: true };\n  }\n}\n\n/**\n * Parses the given file path into pathname, search, query, and hash, if the options allow it.\n *\n * @param   {string}          p       - The file path to parse\n * @param   {PathOptions}     options - Options that determine whether queries and hashes are allowed\n * @returns {object}\n */\nfunction parsePath (p, options) {\n  var hash = '', search = '', query = {};\n  options = options || {};\n\n  if (options.allowFileHash) {\n    // Separate the hash from the file path\n    var hashIndex = p.indexOf('#');\n    if (hashIndex >= 0) {\n      hash = p.substr(hashIndex);\n      p = p.substr(0, hashIndex);\n    }\n  }\n\n  if (options.allowFileQuery) {\n    // Separate the query from the file path\n    var queryIndex = p.lastIndexOf('?');\n    if (queryIndex >= 0) {\n      search = p.substr(queryIndex);\n      query = search.substr(1);\n      if (options.parseQueryString || options.parseQueryString === undefined) {\n        query = querystring.parse(query);\n      }\n      p = p.substr(0, queryIndex);\n    }\n  }\n\n  return {\n    pathname: p,\n    search: search,\n    query: query,\n    hash: hash\n  };\n}\n\n/**\n * Performs a fast, minimal parsing of the given path(s).\n *\n * @param   {*[]}     args        - The paths to parse, and possibly a {@link PathOptions} argument\n * @param   {boolean} [isUrl]     - Whether to treat all paths as URLs\n * @param   {boolean} [isFS]      - Whether to treat all paths as filesystem paths\n * @returns {object}\n */\nfunction fastParse (args, isUrl, isFS) {\n  args = getArgs(args);\n  var paths = args.paths;\n  var options = args.options;\n\n  var result = {\n    last: paths.length - 1,\n    hasUrls: false,\n    hrefs: [],\n    pathnames: [],\n    searches: [],\n    hashes: []\n  };\n\n  // Parse each path\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    var href, pathname, search, hash, parsedPath;\n\n    if (path instanceof OmniPath) {\n      // Yay! It's already parsed\n      if (isUrl || path.isUrl) {\n        result.hasUrls = true;\n        href = path.href;\n        pathname = path.formatPart('pathname');\n      }\n      else {\n        href = pathname = path.pathname;\n      }\n      search = path.search;\n      hash = path.hash;\n\n      if (i === 0 && !options) {\n        // If no options are explicitly passed, and the first arg\n        // is an OmniPath, then we can use it's options\n        options = path._options;\n      }\n    }\n    else {\n      href = toString(path);\n\n      if (isUrl || (!isFS && protocolPattern.test(href))) {\n        // It's a URL\n        result.hasUrls = true;\n        parsedPath = parsePath(href, { allowFileQuery: true, allowFileHash: true, parseQueryString: false });\n        pathname = parsedPath.pathname;\n        search = parsedPath.search;\n        hash = parsedPath.hash;\n      }\n      else {\n        // It's a file path\n        if (options) {\n          // Split the pathname from the search/hash\n          parsedPath = parsePath(href,\n            { allowFileQuery: options.allowFileQuery, allowFileHash: options.allowFileHash, parseQueryString: false });\n          pathname = parsedPath.pathname;\n          search = parsedPath.search;\n          hash = parsedPath.hash;\n        }\n        else {\n          // File paths with query/hash aren't supported\n          pathname = href;\n          search = hash = '';\n        }\n      }\n    }\n\n    result.hrefs.push(href);\n    result.pathnames.push(pathname);\n    result.searches.push(search);\n    result.hashes.push(hash);\n  }\n\n  return result;\n}\n\n/**\n * Splits the given argument list into separate arguments.\n *\n * @param   {Arguments} args - The argument list to be split\n * @returns {{paths: Array, options: ?Options}}\n */\nfunction getArgs (args) {\n  var result = {\n    paths: [],\n    options: null\n  };\n\n  if (args && args.length > 0) {\n    var lastArg = args[args.length - 1];\n    if (typeof (lastArg) === 'string' || lastArg instanceof OmniPath || lastArg instanceof url.Url) {\n      // There is no \"options\" argument.  All arguments are paths.\n      result.paths = Array.prototype.slice.call(args);\n    }\n    else {\n      // The last argument is the \"options\" argument.  All others are paths.\n      result.options = lastArg;\n      result.paths = Array.prototype.slice.call(args, 0, args.length - 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Determines whether the given path (or segment) begins with a separator character.\n *\n * @param {string} p - A path or segment\n * @returns {boolean}\n */\nfunction startsWithAnySeparator (p) {\n  var firstChar = p[0];\n  return firstChar === '/' || firstChar === '\\\\';\n}\n\n/**\n * Determines whether the given path (or segment) ends with a separator character.\n *\n * @param {string} p - A path or segment\n * @returns {boolean}\n */\nfunction endsWithAnySeparator (p) {\n  var lastChar = p.substr(-1);\n  return lastChar === '/' || lastChar === '\\\\';\n}\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n",
    "'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n"
  ]
}